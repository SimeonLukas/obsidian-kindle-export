/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// main.ts
__export(exports, {
  default: () => Kindle
});
var import_buffer = __toModule(require_buffer());
var import_obsidian2 = __toModule(require("obsidian"));

// settings.ts
var import_obsidian = __toModule(require("obsidian"));
var KindleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Kindle Settings" });
    containerEl.createEl("p", { text: "Set your data for your Kindle. Use your Mailadress wich is approved by Amazon." });
    new import_obsidian.Setting(containerEl).setName("Author").setDesc("Default author for new documents").addText((text) => text.setPlaceholder("Obsidian").setValue(this.plugin.settings.author).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.author = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Email").setDesc("Approved Email for your Kindle").addText((text) => text.setPlaceholder("you@obsidian.md").setValue(this.plugin.settings.sendmail).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.sendmail = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Kindle Email").setDesc("Your Kindle Email").addText((text) => text.setPlaceholder("you@kindle.com").setValue(this.plugin.settings.kindlemail).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.kindlemail = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Host").setDesc("Your SMTP Host (e.g. smtp.gmail.com)").addText((text) => text.setPlaceholder("smtp.obsidian.md").setValue(this.plugin.settings.smtphost).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.smtphost = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Port").setDesc("Your SMTP Port (e.g. 587)").addText((text) => text.setPlaceholder("465").setValue(this.plugin.settings.port).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.port = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP User").setDesc("Username for your SMTP Server e.g. your Mailadress").addText((text) => text.setPlaceholder("you@obsidian.md").setValue(this.plugin.settings.user).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.user = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Password").setDesc("Your SMTP Password").addText((text) => text.setPlaceholder("********").setValue(this.plugin.settings.pass).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pass = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Backend").setDesc("Your Backendadress (e.g. https://staneks.de/apps/md2mobi/) can be used for free or host your own Backend.").addText((text) => text.setPlaceholder("https://ob2ki.com").setValue(this.plugin.settings.backend).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.backend = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    containerEl.createEl("hr");
    containerEl.createEl("p", { text: "Host your own Obsidian2Kindle-Converter." });
    containerEl.createEl("a", { text: "Fork from Github \u{1F517}", href: "https://github.com/SimeonLukas/Obsidian2Kindle" });
    containerEl.createEl("hr");
    containerEl.createEl("h1", { text: "\u23F3Beta Settings" });
    new import_obsidian.Setting(containerEl).setName("Generate TOC").setDesc("Generate Table of Contents. This is a beta feature and may not work correctly.").addToggle((toggle) => toggle.setValue(this.plugin.settings.toc).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.toc = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  author: "",
  sendmail: "",
  kindlemail: "",
  port: "",
  smtphost: "",
  pass: "",
  backend: "https://staneks.de/apps/md2mobi/"
};
var Kindle = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new KindleSettingTab(this.app, this));
      this.addCommand({
        id: "Export",
        name: "Export",
        callback: () => __async(this, null, function* () {
          let Inhalt = "";
          let imagelist = [];
          let imagename = [];
          let lang = localStorage.getItem("language");
          let dokument = this.app.workspace.getActiveFile();
          let data = yield this.app.vault.read(dokument);
          let lines = data.split("\n");
          let result = yield this.GetEbook(lines, Inhalt, imagelist, imagename);
          Inhalt = result.Inhalt;
          imagelist = result.imagelist;
          imagename = result.imagename;
          let datei = this.app.workspace.getActiveFile().basename;
          let host = this.settings.smtphost;
          let port = this.settings.port;
          let pass = this.settings.pass;
          let kindlemail = this.settings.kindlemail;
          let sendmail = this.settings.sendmail;
          let author = this.settings.author;
          let user = this.settings.user;
          let toc = this.settings.toc;
          let backend = this.settings.backend;
          if (host == "" || port == "" || pass == "" || kindlemail == "" || sendmail == "" || author == "" || user == "" || backend == "") {
            if (lang == "de") {
              new Notice("Bitte geben Sie alle Einstellungen ein.");
            } else {
              new Notice("Please fill in the settings!");
            }
            return;
          }
          if (lang == "de") {
            new Notice("\u{1F603} Dein Dokument " + datei + " wird nun exportiert.");
          } else {
            new Notice("\u{1F603} Your Note " + datei + " is being converted to a ebook");
          }
          var url = this.settings.backend;
          var formData = new FormData();
          for (let i = 0; i < imagelist.length; i++) {
            formData.append("file" + i, imagelist[i]);
          }
          formData.append("lang", lang);
          formData.append("Bilder", imagename);
          formData.append("text", Inhalt);
          formData.append("title", datei);
          formData.append("author", author);
          formData.append("email", sendmail);
          formData.append("kindle", kindlemail);
          formData.append("port", port);
          formData.append("host", host);
          formData.append("pass", pass);
          formData.append("user", user);
          formData.append("toc", toc);
          fetch(url, {
            method: "POST",
            body: formData
          }).then(function(response) {
            return response.text();
          }).then(function(body) {
            new Notice(body);
          });
        })
      });
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  GetEbook(lines, Inhalt, imagelist, imagename) {
    return __async(this, null, function* () {
      for (let i = 0; i < lines.length; i++) {
        let text = lines[i];
        if (text.contains("![")) {
          let dateiname = text.match(/!\[\[(.*?)\]\]/);
          if (dateiname != null) {
            let anker = dateiname[1].split("#");
            let files = this.app.vault.getFiles().length;
            for (let i2 = 0; i2 < files; i2++) {
              let file = this.app.vault.getFiles()[i2];
              if (file.name == dateiname[1] && file.extension != "md") {
                let data = yield this.app.vault.readBinary(file);
                let base64 = import_buffer.Buffer.from(data).toString("base64");
                imagename.push(file.name);
                imagelist.push(base64);
                Inhalt += '\n<p><img class="image" src="uploads/' + file.name + '"></p>\n';
              }
              if (file.name == anker[0] + ".md" || file.name == dateiname[1] + ".md") {
                let data = yield this.app.vault.read(file);
                text = import_buffer.Buffer.from(data).toString("utf8");
                for (let i3 = 1; i3 < anker.length; i3++) {
                  if (anker[i3] != void 0) {
                    if (anker[i3].contains("^")) {
                      let ankercaret = text.indexOf(anker[i3]);
                      text = text.substring(0, ankercaret);
                      text = text.substring(text.lastIndexOf("\n"));
                      dateiname[0] = dateiname[0].replace("^", "|");
                    } else {
                      let pos = text.indexOf(anker[i3]);
                      text = text.substring(pos + anker[i3].length);
                      let pos2 = text.indexOf("\n#", 30);
                      text = text.substring(0, pos2);
                    }
                  }
                }
                dateiname[0] = dateiname[0].replace("![[", "").replace("]]", "").replace("#", ">");
                text = "<h3><i>" + dateiname[0] + "</i></h3>\n" + text;
                let lines2 = text.split("\n");
                let nextmd = yield this.GetEbook(lines2, Inhalt, imagelist, imagename);
                Inhalt = nextmd.Inhalt;
              } else {
              }
            }
          }
        } else {
          Inhalt += text + "\n";
        }
      }
      return { Inhalt, imagelist, imagename };
    });
  }
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwgIm1haW4udHMiLCAic2V0dGluZ3MudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwgIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCAiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iLCAiaW1wb3J0IHtcclxuXHRCdWZmZXJcclxufSBmcm9tIFwiLi9ub2RlX21vZHVsZXMvYnVmZmVyXCI7XHJcbmltcG9ydCB7XHJcblx0RWRpdG9yLFxyXG5cdFBsdWdpbixcclxufSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHtcclxuXHRLaW5kbGVTZXR0aW5nVGFiXHJcbn0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcclxuXHJcbmludGVyZmFjZSBLaW5kbGVQbHVnaW5TZXR0aW5ncyB7XHJcblx0YXV0aG9yOiBzdHJpbmc7XHJcblx0c2VuZG1haWw6IHN0cmluZztcclxuXHRraW5kbGVtYWlsOiBzdHJpbmc7XHJcblx0cG9ydDogc3RyaW5nO1xyXG5cdGhvc3Q6IHN0cmluZztcclxuXHRwYXNzOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBhcnRpYWwgPCBLaW5kbGVQbHVnaW5TZXR0aW5ncyA+ID0ge1xyXG5cclxuXHRhdXRob3I6IFwiXCIsXHJcblx0c2VuZG1haWw6IFwiXCIsXHJcblx0a2luZGxlbWFpbDogXCJcIixcclxuXHRwb3J0OiBcIlwiLFxyXG5cdHNtdHBob3N0OiBcIlwiLFxyXG5cdHBhc3M6IFwiXCIsXHJcblx0YmFja2VuZDogXCJodHRwczovL3N0YW5la3MuZGUvYXBwcy9tZDJtb2JpL1wiLFxyXG5cclxuXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW5kbGUgZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdHNldHRpbmdzOiBLaW5kbGVQbHVnaW5TZXR0aW5ncztcclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBLaW5kbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblxyXG4gIFxyXG5cclxuXHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogJ0V4cG9ydCcsXHJcblx0XHRcdG5hbWU6ICdFeHBvcnQnLFxyXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGxldCBJbmhhbHQ6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgbGV0IGltYWdlbGlzdDogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICBsZXQgaW1hZ2VuYW1lOiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0bGV0IGxhbmcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImxhbmd1YWdlXCIpO1xyXG4gICAgICAgIGxldCBkb2t1bWVudCA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRva3VtZW50KVxyXG4gICAgICAgIGxldCBsaW5lcyA9IGRhdGEuc3BsaXQoXCJcXG5cIilcclxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5HZXRFYm9vayhsaW5lcywgSW5oYWx0LCBpbWFnZWxpc3QsIGltYWdlbmFtZSk7XHJcbiAgICAgICAgSW5oYWx0ID0gcmVzdWx0LkluaGFsdDtcclxuICAgICAgICBpbWFnZWxpc3QgPSByZXN1bHQuaW1hZ2VsaXN0O1xyXG4gICAgICAgIGltYWdlbmFtZSA9IHJlc3VsdC5pbWFnZW5hbWU7XHJcblx0XHRcdFx0bGV0IGRhdGVpID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKS5iYXNlbmFtZTtcclxuXHRcdFx0XHQvLyBDb3ZlcmJpbGQgdG9Eb1xyXG5cdFx0XHRcdC8vIGxldCBjb3ZlciA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCkucGFyZW50LnBhdGggKyBcIi9jb3Zlci5wbmdcIjtcclxuXHRcdFx0XHQvLyBsZXQgYmFzZTY0Y292ZXIgPSBcIlwiO1xyXG5cdFx0XHRcdC8vIGlmIChjb3ZlciAhPSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHQvLyBcdGxldCBjb3ZlcmRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlYWRCaW5hcnkoY292ZXIpO1xyXG5cdFx0XHRcdC8vIFx0YmFzZTY0Y292ZXIgPSBCdWZmZXIuZnJvbShjb3ZlcmRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuXHRcdFx0XHQvLyB9XHJcblx0XHRcdFx0Ly8gZWxzZXtcclxuXHRcdFx0XHQvLyBcdGJhc2U2NGNvdmVyID0gXCJmYWxzZVwiO1xyXG5cdFx0XHRcdC8vIH1cclxuXHRcdFx0XHRsZXQgaG9zdCA9IHRoaXMuc2V0dGluZ3Muc210cGhvc3Q7XHJcblx0XHRcdFx0bGV0IHBvcnQgPSB0aGlzLnNldHRpbmdzLnBvcnQ7XHJcblx0XHRcdFx0bGV0IHBhc3MgPSB0aGlzLnNldHRpbmdzLnBhc3M7XHJcblx0XHRcdFx0bGV0IGtpbmRsZW1haWwgPSB0aGlzLnNldHRpbmdzLmtpbmRsZW1haWw7XHJcblx0XHRcdFx0bGV0IHNlbmRtYWlsID0gdGhpcy5zZXR0aW5ncy5zZW5kbWFpbDtcclxuXHRcdFx0XHRsZXQgYXV0aG9yID0gdGhpcy5zZXR0aW5ncy5hdXRob3I7XHJcblx0XHRcdFx0bGV0IHVzZXIgPSB0aGlzLnNldHRpbmdzLnVzZXI7XHJcblx0XHRcdFx0bGV0IHRvYyA9IHRoaXMuc2V0dGluZ3MudG9jO1xyXG5cdFx0XHRcdGxldCBiYWNrZW5kID0gdGhpcy5zZXR0aW5ncy5iYWNrZW5kO1xyXG5cdFx0XHRcdGlmIChob3N0ID09IFwiXCIgfHwgcG9ydCA9PSBcIlwiIHx8IHBhc3MgPT0gXCJcIiB8fCBraW5kbGVtYWlsID09IFwiXCIgfHwgc2VuZG1haWwgPT0gXCJcIiB8fCBhdXRob3IgPT0gXCJcIiB8fCB1c2VyID09IFwiXCIgfHwgYmFja2VuZCA9PSBcIlwiKSB7XHJcblx0XHRcdFx0XHRpZiAobGFuZyA9PSBcImRlXCIpIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJCaXR0ZSBnZWJlbiBTaWUgYWxsZSBFaW5zdGVsbHVuZ2VuIGVpbi5cIik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJQbGVhc2UgZmlsbCBpbiB0aGUgc2V0dGluZ3MhXCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhkYXRlaSk7XHJcblx0XHRcdFx0aWYgKGxhbmcgPT0gXCJkZVwiKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZSgnXHVEODNEXHVERTAzIERlaW4gRG9rdW1lbnQgJyArIGRhdGVpICsnIHdpcmQgbnVuIGV4cG9ydGllcnQuJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdG5ldyBOb3RpY2UoJ1x1RDgzRFx1REUwMyBZb3VyIE5vdGUgJyArIGRhdGVpICsgJyBpcyBiZWluZyBjb252ZXJ0ZWQgdG8gYSBlYm9vaycpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgdXJsID0gdGhpcy5zZXR0aW5ncy5iYWNrZW5kO1xyXG5cdFx0XHRcdHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnICsgaSwgaW1hZ2VsaXN0W2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gQ292ZXJiaWxkIHRvRG9cclxuXHRcdFx0XHQvLyBmb3JtRGF0YS5hcHBlbmQoJ2NvdmVyJywgYmFzZTY0Y292ZXIpO1xyXG5cdFx0XHRcdC8vIGdldCBsYW5ndWFnZVxyXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgnbGFuZycsIGxhbmcpO1xyXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgnQmlsZGVyJywgaW1hZ2VuYW1lKTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3RleHQnLCBJbmhhbHQpO1xyXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgndGl0bGUnLCBkYXRlaSk7XHJcblx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKCdhdXRob3InLCBhdXRob3IpO1xyXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgnZW1haWwnLCBzZW5kbWFpbCk7XHJcblx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKCdraW5kbGUnLCBraW5kbGVtYWlsKTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3BvcnQnLCBwb3J0KTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ2hvc3QnLCBob3N0KTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3Bhc3MnLCBwYXNzKTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3VzZXInLCB1c2VyKTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3RvYycsIHRvYyk7XHJcblx0XHRcdFx0ZmV0Y2godXJsLCB7XHJcblx0XHRcdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHRcdFx0XHRib2R5OiBmb3JtRGF0YSxcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQudGhlbihmdW5jdGlvbiAoYm9keSkge1xyXG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGJvZHkpO1xyXG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhib2R5KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuXHRcdC8vIGNvbnNvbGUubG9nKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcclxuXHR9XHJcblxyXG4gIGFzeW5jIEdldEVib29rKGxpbmVzOnN0cmluZ1tdICwgSW5oYWx0OnN0cmluZywgaW1hZ2VsaXN0OnN0cmluZ1tdLCBpbWFnZW5hbWU6c3RyaW5nW10peyBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IHRleHQgPSBsaW5lc1tpXTtcclxuICAgICAgaWYgKHRleHQuY29udGFpbnMoXCIhW1wiKSkge1xyXG4gICAgICAgICAgbGV0IGRhdGVpbmFtZSA9IHRleHQubWF0Y2goLyFcXFtcXFsoLio/KVxcXVxcXS8pO1x0XHQgIFxyXG4gICAgICAgICAgaWYgKGRhdGVpbmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZyhkYXRlaW5hbWVbMV0pO1xyXG4gICAgICAgICAgbGV0IGFua2VyID0gZGF0ZWluYW1lWzFdLnNwbGl0KFwiI1wiKTtcclxuICAgICAgICAgIGxldCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldEZpbGVzKCkubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0RmlsZXMoKVtpXTtcclxuICAgICAgICAgICAgaWYgKGZpbGUubmFtZSA9PSBkYXRlaW5hbWVbMV0gJiYgZmlsZS5leHRlbnNpb24gIT0gXCJtZFwiKSB7XHJcbiAgICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkQmluYXJ5KGZpbGUpO1xyXG4gICAgICAgICAgICAgIGxldCBiYXNlNjQgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcbiAgICAgICAgICAgICAgaW1hZ2VuYW1lLnB1c2goZmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgICBpbWFnZWxpc3QucHVzaChiYXNlNjQpO1xyXG4gICAgICAgICAgICAgIEluaGFsdCArPSAnXFxuPHA+PGltZyBjbGFzcz1cImltYWdlXCIgc3JjPVwidXBsb2Fkcy8nICsgZmlsZS5uYW1lICsgJ1wiPjwvcD4nICsgJ1xcbic7XHJcbiAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ0JpbGQgd3VyZGUgaGluenVnZWZcdTAwRkNndCEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlsZS5uYW1lID09IGFua2VyWzBdICsgJy5tZCcgfHwgZmlsZS5uYW1lID09IGRhdGVpbmFtZVsxXSArICcubWQnKSB7XHJcbiAgICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xyXG4gICAgICAgICAgICAgIHRleHQgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygndXRmOCcpO1xyXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYW5rZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhbmtlcltpXSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGFua2VyW2ldLmNvbnRhaW5zKFwiXlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhbmtlcmNhcmV0ID0gdGV4dC5pbmRleE9mKGFua2VyW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgYW5rZXJjYXJldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKHRleHQubGFzdEluZGV4T2YoXCJcXG5cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVpbmFtZVswXSA9IGRhdGVpbmFtZVswXS5yZXBsYWNlKCdeJywgXCJ8XCIpOyAgICAgICBcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICBsZXQgcG9zID0gdGV4dC5pbmRleE9mKGFua2VyW2ldKTtcclxuICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKHBvcyArIGFua2VyW2ldLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgIGxldCBwb3MyID0gdGV4dC5pbmRleE9mKCdcXG4jJywgMzApO1xyXG4gICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgcG9zMik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBkYXRlaW5hbWVbMF0gPSBkYXRlaW5hbWVbMF0ucmVwbGFjZSgnIVtbJywgXCJcIikucmVwbGFjZSgnXV0nLCBcIlwiKS5yZXBsYWNlKCcjJywgXCI+XCIpO1xyXG4gICAgICAgICAgICAgIHRleHQgPSAnPGgzPjxpPicgKyBkYXRlaW5hbWVbMF0gKyAnPC9pPjwvaDM+XFxuJyArIHRleHQ7XHJcbiAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2codGV4dCk7XHJcbiAgICAgICAgICAgICAgbGV0IGxpbmVzMiA9IHRleHQuc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgICAgbGV0IG5leHRtZCA9IGF3YWl0IHRoaXMuR2V0RWJvb2sobGluZXMyLCBJbmhhbHQsIGltYWdlbGlzdCwgaW1hZ2VuYW1lKTtcclxuICAgICAgICAgICAgICBJbmhhbHQgPSBuZXh0bWQuSW5oYWx0O1xyXG4gICAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdFaW5nZWJldHRldGVzIE1EIHd1cmRlIGhpbnp1Z2VmXHUwMEZDZ3QhJyk7ICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZygnRGF0ZWkgbmljaHQgZ2VmdW5kZW4hJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBJbmhhbHQgKz0gdGV4dCArICdcXG4nO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICAvLyBjb25zb2xlLmxvZyhJbmhhbHQpO1xyXG4gICAgcmV0dXJuIHtJbmhhbHQsIGltYWdlbGlzdCwgaW1hZ2VuYW1lfTtcclxuICAgIFxyXG4gIH1cclxuXHJcbn0iLCAiaW1wb3J0IEtpbmRsZVBsdWdpbiBmcm9tIFwibWFpblwiO1xyXG5pbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBLaW5kbGVTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgcGx1Z2luOiBLaW5kbGVQbHVnaW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEtpbmRsZVBsdWdpbikge1xyXG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xyXG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgfVxyXG5cclxuICBkaXNwbGF5KCk6IHZvaWQge1xyXG4gICAgbGV0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblxyXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJLaW5kbGUgU2V0dGluZ3NcIiB9KTtcclxuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IFwiU2V0IHlvdXIgZGF0YSBmb3IgeW91ciBLaW5kbGUuIFVzZSB5b3VyIE1haWxhZHJlc3Mgd2ljaCBpcyBhcHByb3ZlZCBieSBBbWF6b24uXCIgfSk7XHJcblxyXG5cclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkF1dGhvclwiKVxyXG4gICAgICAuc2V0RGVzYyhcIkRlZmF1bHQgYXV0aG9yIGZvciBuZXcgZG9jdW1lbnRzXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIk9ic2lkaWFuXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0aG9yKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRob3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJFbWFpbFwiKVxyXG4gICAgICAuc2V0RGVzYyhcIkFwcHJvdmVkIEVtYWlsIGZvciB5b3VyIEtpbmRsZVwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJ5b3VAb2JzaWRpYW4ubWRcIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZW5kbWFpbClcdFxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZW5kbWFpbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIktpbmRsZSBFbWFpbFwiKVxyXG4gICAgICAuc2V0RGVzYyhcIllvdXIgS2luZGxlIEVtYWlsXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcInlvdUBraW5kbGUuY29tXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mua2luZGxlbWFpbClcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mua2luZGxlbWFpbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlNNVFAgSG9zdFwiKVxyXG4gICAgICAuc2V0RGVzYyhcIllvdXIgU01UUCBIb3N0IChlLmcuIHNtdHAuZ21haWwuY29tKVwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJzbXRwLm9ic2lkaWFuLm1kXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc210cGhvc3QpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNtdHBob3N0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiU01UUCBQb3J0XCIpXHJcbiAgICAgIC5zZXREZXNjKFwiWW91ciBTTVRQIFBvcnQgKGUuZy4gNTg3KVwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCI0NjVcIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wb3J0KVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wb3J0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJTTVRQIFVzZXJcIilcclxuICAgICAgLnNldERlc2MoXCJVc2VybmFtZSBmb3IgeW91ciBTTVRQIFNlcnZlciBlLmcuIHlvdXIgTWFpbGFkcmVzc1wiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJ5b3VAb2JzaWRpYW4ubWRcIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VyKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuXHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJTTVRQIFBhc3N3b3JkXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiWW91ciBTTVRQIFBhc3N3b3JkXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIioqKioqKioqXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucGFzcylcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGFzcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkJhY2tlbmRcIilcclxuICAgICAgLnNldERlc2MoXCJZb3VyIEJhY2tlbmRhZHJlc3MgKGUuZy4gaHR0cHM6Ly9zdGFuZWtzLmRlL2FwcHMvbWQybW9iaS8pIGNhbiBiZSB1c2VkIGZvciBmcmVlIG9yIGhvc3QgeW91ciBvd24gQmFja2VuZC5cIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiaHR0cHM6Ly9vYjJraS5jb21cIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5iYWNrZW5kKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iYWNrZW5kID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImhyXCIpO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBcIkhvc3QgeW91ciBvd24gT2JzaWRpYW4yS2luZGxlLUNvbnZlcnRlci5cIn0pO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImFcIiwgeyB0ZXh0OiBcIkZvcmsgZnJvbSBHaXRodWIgXHVEODNEXHVERDE3XCIsIGhyZWY6IFwiaHR0cHM6Ly9naXRodWIuY29tL1NpbWVvbkx1a2FzL09ic2lkaWFuMktpbmRsZVwifSk7XHJcbiAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaHJcIik7XHJcbiAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIlx1MjNGM0JldGEgU2V0dGluZ3NcIiB9KTtcclxuICAgICAgXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkdlbmVyYXRlIFRPQ1wiKVxyXG4gICAgICAuc2V0RGVzYyhcIkdlbmVyYXRlIFRhYmxlIG9mIENvbnRlbnRzLiBUaGlzIGlzIGEgYmV0YSBmZWF0dXJlIGFuZCBtYXkgbm90IHdvcmsgY29ycmVjdGx5LlwiKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XHJcbiAgICAgICAgdG9nZ2xlXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudG9jKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy50b2MgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICBcclxuICAgIH1cclxuICAgIH1cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFFQSxZQUFRLGFBQWE7QUFDckIsWUFB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
