/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// buffer/index.js
var require_buffer = __commonJS({
  "buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// main.ts
__export(exports, {
  default: () => Kindle
});
var import_buffer = __toModule(require_buffer());
var import_obsidian2 = __toModule(require("obsidian"));

// settings.ts
var import_obsidian = __toModule(require("obsidian"));
var KindleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Kindle settings" });
    containerEl.createEl("p", { text: "Set your data for your Kindle. Use your email which is approved by Amazon." });
    new import_obsidian.Setting(containerEl).setName("Author").setDesc("Default author for new documents").addText((text) => text.setPlaceholder("Obsidian").setValue(this.plugin.settings.author).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.author = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Email").setDesc("Approved Email for your Kindle").addText((text) => text.setPlaceholder("you@obsidian.md").setValue(this.plugin.settings.sendmail).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.sendmail = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Kindlemail").setDesc("Your Kindle/PocketBook email").addText((text) => text.setPlaceholder("you@kindle.com").setValue(this.plugin.settings.kindlemail).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.kindlemail = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Host").setDesc("Your SMTP host (e.g. smtp.gmail.com)").addText((text) => text.setPlaceholder("smtp.obsidian.md").setValue(this.plugin.settings.smtphost).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.smtphost = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Port").setDesc("Your SMTP port (e.g. 587)").addText((text) => text.setPlaceholder("465").setValue(this.plugin.settings.port).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.port = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP User").setDesc("Username for your SMTP server e.g. your Mailadress").addText((text) => text.setPlaceholder("you@obsidian.md").setValue(this.plugin.settings.user).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.user = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Password").setDesc("Your SMTP password").addText((text) => text.setPlaceholder("********").setValue(this.plugin.settings.pass).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pass = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Backend").setDesc("Your backendadress (e.g. https://staneks.de/apps/md2mobi/) can be used for free or host your own Backend.").addText((text) => text.setPlaceholder("https://ob2ki.com").setValue(this.plugin.settings.backend).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.backend = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Generate TOC").setDesc("Generate Table of Contents.").addToggle((toggle) => toggle.setValue(this.plugin.settings.toc).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.toc = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    containerEl.createEl("hr");
    containerEl.createEl("h1", { text: "\u2B50 Suggested features" });
    new import_obsidian.Setting(containerEl).setName("Pagebreak by '---'").setDesc("Suggested feature: Activate pagebreak by '---'").addToggle((toggle) => toggle.setValue(this.plugin.settings.pagebreak).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pagebreak = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Markdown merge").setDesc("Suggested feature: Merge .md files into one file (adds Kindle: Mergedown command) Plugin reloads after saving.").addToggle((toggle) => toggle.setValue(this.plugin.settings.mergedown).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.mergedown = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
      this.app.plugins.unloadPlugin("obsidian-kindle-export");
      this.app.plugins.loadPlugin("obsidian-kindle-export");
    })));
    new import_obsidian.Setting(containerEl).setName("Exportpath").setDesc("Set the path where you want to export your files to. (e.g. /folder)").addText((text) => text.setPlaceholder("/folder").setValue(this.plugin.settings.expath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.expath = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Add Ribbon-Icon").setDesc("Suggested feature: Add Ribbon-Icon for the Export-Command. Plugin reloads after saving.").addToggle((toggle) => toggle.setValue(this.plugin.settings.ribbonicon).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ribbonicon = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
      this.app.plugins.unloadPlugin("obsidian-kindle-export");
      this.app.plugins.loadPlugin("obsidian-kindle-export");
    })));
    containerEl.createEl("hr");
    containerEl.createEl("p", { text: "Host your own Obsidian2Kindle-Converter." });
    containerEl.createEl("a", { text: "Fork from Github \u{1F517}", href: "https://github.com/SimeonLukas/Obsidian2Kindle" });
    containerEl.createEl("br");
    containerEl.createEl("a", { text: "Buy me a \u2615", href: "https://www.buymeacoffee.com/simeonlukas" });
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  author: "",
  sendmail: "",
  kindlemail: "",
  port: "",
  smtphost: "",
  pass: "",
  expath: "",
  backend: "https://staneks.de/apps/md2mobi/"
};
var Kindle = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new KindleSettingTab(this.app, this));
      if (this.settings.mergedown == true) {
        this.addCommand({
          id: "Mergedown",
          name: "Mergedown",
          callback: () => __async(this, null, function* () {
            let Inhalt = "";
            let imagelist = [];
            let imagename = [];
            let links = [];
            let lang2 = localStorage.getItem("language");
            let dokument = this.app.workspace.getActiveFile();
            if (dokument == null || dokument.extension != "md") {
              new import_obsidian2.Notice("\u274C No active .md file. Please open a .md file first!");
              return;
            }
            let Alllinks = this.app.metadataCache.resolvedLinks[dokument.path];
            links = Object.entries(Alllinks);
            let data = yield this.app.vault.cachedRead(dokument);
            data = data.replace(/]]/g, "]]\n");
            let lines = data.split("\n");
            let result = yield this.Mergedown(lines, Inhalt, imagelist, imagename, links);
            Inhalt = result.Inhalt;
            Inhalt = Inhalt.replace(/%%[\s\S]*?%%/g, "");
            Inhalt = Inhalt.replace("\n]]", "");
            let time = new Date().getTime();
            let expath = this.settings.expath;
            this.app.vault.createFolder(expath);
            this.app.vault.create(expath + "/" + dokument.basename + "_mergedown_" + time + ".md", Inhalt);
            if (lang2 == "de") {
              new import_obsidian2.Notice("\u2714\uFE0F Mergedown erfolgreich!");
            } else {
              new import_obsidian2.Notice("\u2714\uFE0F Mergedown successful!");
            }
          })
        });
      }
      this.addCommand({
        id: "Export",
        name: "Export",
        callback: () => {
          this.export();
        }
      });
      if (this.settings.ribbonicon == true) {
        this.addRibbonIcon("paper-plane", "send2E-Reader", () => {
          this.export();
        });
      }
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  getFile(text, links) {
    return __async(this, null, function* () {
      if (text.contains("![[") && text.contains("]]")) {
        let start = text.indexOf("![[");
        let end = text.indexOf("]]", start + 3);
        let name = text.substring(start + 3, end);
        name = "![[" + name + "]]";
        for (let i = 0; i < links.length; i++) {
          let foundLink = links[i][0];
          let chunk = foundLink.split("/");
          foundLink = chunk[chunk.length - 1];
          let extension = foundLink.split(".");
          foundLink = extension[0];
          if (name.contains(foundLink)) {
            var file = links[i][0];
            return [file, name];
          } else {
          }
        }
      } else {
        if (lang == "de") {
          new import_obsidian2.Notice("\u274C Dein Dokument enth\xE4lt unaufgel\xF6ste Dateien. Bitte korrigiere das!");
        } else {
          new import_obsidian2.Notice("\u274C Your document contains unresolved files. Please fix it!");
        }
        return null;
      }
    });
  }
  GetEbook(lines, Inhalt, imagelist, imagename, links) {
    return __async(this, null, function* () {
      for (let i = 0; i < lines.length; i++) {
        let text = lines[i];
        if (text.contains("![[") && text.contains("]]") || text.contains("![") && text.contains(")") && text.contains("http://") && text.contains("https://")) {
          let file = yield this.getFile(text, links);
          let FileLink = file[1];
          file = file[0];
          file = this.app.vault.getAbstractFileByPath(file);
          if (file == this.app.workspace.getActiveFile()) {
            new import_obsidian2.Notice("\u274C You can not embed the file in his own file");
            throw new Error("In the Moment it is not possible to embed the file in his own file");
          }
          if (file.extension == "png" || file.extension == "jpg" || file.extension == "jpeg" || file.extension == "gif" || file.extension == "svg" || file.extension == "bmp") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            var filename = file.name.replace(/[^a-z0-9]/gi, "_").toLowerCase();
            imagename.push(filename);
            imagelist.push(base64);
            Inhalt += '\n<p><img class="intern" src="uploads/' + filename + '"></p>\n\n';
          }
          if (file.extension == "mp3") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            var filename = file.name.replace(/[^a-z0-9]/gi, "_").toLowerCase();
            imagename.push(filename);
            imagelist.push(base64);
            Inhalt += '\n<p><audio class="intern" type="audio/mpeg" src="uploads/' + filename + '" controls="controls"/></p>\n\n';
          }
          if (file.extension == "md") {
            let links2 = [];
            let data = yield this.app.vault.cachedRead(file);
            text = import_buffer.Buffer.from(data).toString("utf8");
            if (text.startsWith("---")) {
              let start = text.indexOf("---");
              let end = text.indexOf("---", start + 3);
              text = text.substring(end + 3);
            }
            let heading = "";
            let Iteration = 0;
            this.app.metadataCache.iterateReferences((sourcePath, reference) => {
              if (reference.link.contains(file.basename) && reference.original == FileLink && Iteration == 0) {
                let anker = reference.link.split("#");
                let ankerSplit = anker.length;
                anker = anker[anker.length - 1];
                heading = "<h3><i>" + reference.displayText + "</i></h3>\n";
                if (anker != void 0 && ankerSplit > 1) {
                  if (anker.contains("^")) {
                    let ankercaret = text.indexOf(anker);
                    text = text.substring(0, ankercaret);
                    text = text.substring(text.lastIndexOf("\n"));
                    heading = "";
                  } else {
                    let pos = text.indexOf(anker);
                    if (pos == -1) {
                      text = text.substring(pos);
                    } else {
                      text = text.substring(pos);
                      text = text.replace(anker, "");
                    }
                    let pos2 = text.indexOf("\n#", 10);
                    if (pos2 == -1) {
                    } else {
                      text = text.substring(0, pos2);
                    }
                  }
                }
                Iteration++;
              }
            });
            text = heading + text;
            let lines2 = text.split("\n");
            let nextmd = yield this.GetEbook(lines2, Inhalt, imagelist, imagename, links2);
            Inhalt = nextmd.Inhalt;
          } else {
          }
        } else {
          if (text.contains("![") && text.contains(")") && text.contains("http://") || text.contains("![") && text.contains(")") && text.contains("https://")) {
            let ImageLink = text.substring(text.indexOf("(") + 1, text.indexOf(")"));
            Inhalt += '<p><img class="extern" src="' + ImageLink + '"></p> \n\n';
          } else {
            Inhalt += text + " \n\n";
          }
        }
      }
      return {
        Inhalt,
        imagelist,
        imagename
      };
    });
  }
  export() {
    return __async(this, null, function* () {
      let Inhalt = "";
      let imagelist = [];
      let imagename = [];
      let links = [];
      let lang2 = "en";
      if (localStorage.getItem("language") !== null) {
        lang2 = localStorage.getItem("language");
      }
      let dokument = this.app.workspace.getActiveFile();
      if (dokument == null || dokument.extension != "md") {
        new import_obsidian2.Notice("\u274C No active .md file. Please open a .md file first!");
        return;
      }
      let Alllinks = this.app.metadataCache.resolvedLinks[dokument.path];
      links = Object.entries(Alllinks);
      let data = yield this.app.vault.cachedRead(dokument);
      if (data.startsWith("---")) {
        let start = data.indexOf("---");
        let end = data.indexOf("---", start + 3);
        data = data.substring(end + 3);
      }
      data = data.replace(/]]/g, "]]\n");
      let lines = data.split("\n");
      let result = yield this.GetEbook(lines, Inhalt, imagelist, imagename, links);
      Inhalt = result.Inhalt;
      imagelist = result.imagelist;
      imagename = result.imagename;
      Inhalt = Inhalt.replace(/%%[\s\S]*?%%/g, "");
      Inhalt = Inhalt.replace(/```dataviewjs[\s\S]*?```/g, "");
      Inhalt = Inhalt.replace(/==[\s\S]*?==/g, "<u>$&</u>");
      Inhalt = Inhalt.replace(/==/g, "");
      if (this.settings.pagebreak == true) {
        Inhalt = Inhalt.replace(/---/g, '---\n<p><div style="page-break-after: always;"></div></p>\n');
      } else {
      }
      let host = this.settings.smtphost;
      let port = this.settings.port;
      let pass = this.settings.pass;
      let kindlemail = this.settings.kindlemail;
      let sendmail = this.settings.sendmail;
      let author = this.settings.author;
      let user = this.settings.user;
      let toc = this.settings.toc;
      let backend = this.settings.backend;
      if (host == "" || port == "" || pass == "" || kindlemail == "" || sendmail == "" || author == "" || user == "" || backend == "") {
        if (lang2 == "de") {
          new import_obsidian2.Notice("Bitte erg\xE4nze die Einstellungen.");
        } else {
          new import_obsidian2.Notice("Please fill in the settings!");
        }
        return;
      }
      if (lang2 == "de") {
        new import_obsidian2.Notice("\u{1F603} Dein Dokument " + dokument.basename + " wird nun exportiert.");
      } else {
        new import_obsidian2.Notice("\u{1F603} Your Note " + dokument.basename + " is being converted to an ebook");
      }
      var url = this.settings.backend;
      var formData = new FormData();
      for (let i = 0; i < imagelist.length; i++) {
        formData.append("file" + i, imagelist[i]);
      }
      formData.append("lang", lang2);
      formData.append("Bilder", imagename);
      formData.append("text", "#" + dokument.basename + "\n" + Inhalt);
      formData.append("title", dokument.basename);
      formData.append("author", author);
      formData.append("email", sendmail);
      formData.append("kindle", kindlemail);
      formData.append("port", port);
      formData.append("host", host);
      formData.append("pass", pass);
      formData.append("user", user);
      formData.append("toc", toc);
      yield fetch(url, {
        method: "POST",
        body: formData
      }).then(function(response) {
        return response.text();
      }).then(function(body) {
        new import_obsidian2.Notice(body);
      }).catch(function() {
        new import_obsidian2.Notice("\u274C Internetconnection error or Server is offline");
      });
    });
  }
  Mergedown(lines, Inhalt, imagelist, imagename, links) {
    return __async(this, null, function* () {
      for (let i = 0; i < lines.length; i++) {
        let text = lines[i];
        if (text.contains("![[") && text.contains("]]") || text.contains("![") && text.contains(")") && text.contains("http://") && text.contains("https://")) {
          let file = yield this.getFile(text, links);
          let FileLink = file[1];
          file = file[0];
          file = this.app.vault.getAbstractFileByPath(file);
          if (file == this.app.workspace.getActiveFile()) {
            new import_obsidian2.Notice("\u274C You can not embed the file in his own file");
            throw new Error("In the Moment it is not possible to embed the file in his own file");
          }
          if (file.extension == "png" || file.extension == "jpg" || file.extension == "jpeg" || file.extension == "gif" || file.extension == "svg" || file.extension == "bmp") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            imagename.push(file.name);
            imagelist.push(base64);
            Inhalt += "\n![" + file.name + "](data:image/" + file.extension + ";base64," + base64 + ")\n";
          }
          if (file.extension == "mp4" || file.extension == "webm" || file.extension == "ogv" || file.extension == "avi" || file.extension == "mov" || file.extension == "wmv" || file.extension == "mpg" || file.extension == "mpeg" || file.extension == "mkv" || file.extension == "flv" || file.extension == "swf" || file.extension == "vob" || file.extension == "m4v" || file.extension == "m4a" || file.extension == "m4b" || file.extension == "m4r" || file.extension == "3gp" || file.extension == "3g2" || file.extension == "f4v" || file.extension == "f4a" || file.extension == "f4b") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            Inhalt += '\n<video controls><source src="data:video/' + file.extension + ";base64," + base64 + '" type="video/' + file.extension + '"></video>\n';
          }
          if (file.extension == "mp3" || file.extension == "ogg" || file.extension == "wav" || file.extension == "flac") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            Inhalt += '\n<audio controls><source src="data:audio/' + file.extension + ";base64," + base64 + '" type="audio/' + file.extension + '"></audio>\n';
          }
          if (file.extension == "md") {
            let links2 = [];
            let data = yield this.app.vault.cachedRead(file);
            text = import_buffer.Buffer.from(data).toString("utf8");
            if (text.startsWith("---")) {
              let start = text.indexOf("---");
              let end = text.indexOf("---", start + 3);
              text = text.substring(end + 3);
            }
            let heading = "";
            let Iteration = 0;
            this.app.metadataCache.iterateReferences((sourcePath, reference) => {
              if (reference.link.contains(file.basename) && reference.original == FileLink && Iteration == 0) {
                let anker = reference.link.split("#");
                let ankerSplit = anker.length;
                anker = anker[anker.length - 1];
                heading = "<h3><i>" + reference.displayText + "</i></h3>\n";
                if (anker != void 0 && ankerSplit > 1) {
                  if (anker.contains("^")) {
                    let ankercaret = text.indexOf(anker);
                    text = text.substring(0, ankercaret);
                    text = text.substring(text.lastIndexOf("\n"));
                    heading = "";
                  } else {
                    let pos = text.indexOf(anker);
                    if (pos == -1) {
                      text = text.substring(pos);
                    } else {
                      text = text.substring(pos);
                      text = text.replace(anker, "");
                    }
                    let pos2 = text.indexOf("\n#", 10);
                    if (pos2 == -1) {
                    } else {
                      text = text.substring(0, pos2);
                    }
                  }
                }
                Iteration++;
              }
            });
            text = heading + text;
            let lines2 = text.split("\n");
            let nextmd = yield this.Mergedown(lines2, Inhalt, imagelist, imagename, links2);
            Inhalt = nextmd.Inhalt;
          }
        } else {
          if (text.contains("![") && text.contains(")") && text.contains("http://") || text.contains("![") && text.contains(")") && text.contains("https://")) {
            Inhalt += text + "\n";
          } else {
            Inhalt += text + "\n";
          }
        }
      }
      return {
        Inhalt,
        imagelist,
        imagename
      };
    });
  }
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsICJidWZmZXIvaW5kZXguanMiLCAibWFpbi50cyIsICJzZXR0aW5ncy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCAiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsICIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiIsICJpbXBvcnQge1xyXG5cdEJ1ZmZlclxyXG59IGZyb20gXCIuL2J1ZmZlclwiO1xyXG5pbXBvcnQge1xyXG5cdE5vdGljZSxcclxuXHRQbHVnaW4sXHJcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7XHJcblx0S2luZGxlU2V0dGluZ1RhYlxyXG59IGZyb20gXCIuL3NldHRpbmdzXCI7XHJcbmltcG9ydCB7IGZhaWwgfSBmcm9tIFwiYXNzZXJ0XCI7XHJcblxyXG5cclxuXHJcbmludGVyZmFjZSBLaW5kbGVQbHVnaW5TZXR0aW5ncyB7XHJcblx0YXV0aG9yOiBzdHJpbmc7XHJcblx0c2VuZG1haWw6IHN0cmluZztcclxuXHRraW5kbGVtYWlsOiBzdHJpbmc7XHJcblx0cG9ydDogc3RyaW5nO1xyXG5cdGhvc3Q6IHN0cmluZztcclxuXHRwYXNzOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBhcnRpYWwgPCBLaW5kbGVQbHVnaW5TZXR0aW5ncyA+ID0ge1xyXG5cclxuXHRhdXRob3I6IFwiXCIsXHJcblx0c2VuZG1haWw6IFwiXCIsXHJcblx0a2luZGxlbWFpbDogXCJcIixcclxuXHRwb3J0OiBcIlwiLFxyXG5cdHNtdHBob3N0OiBcIlwiLFxyXG5cdHBhc3M6IFwiXCIsXHJcblx0ZXhwYXRoOiBcIlwiLFxyXG5cdGJhY2tlbmQ6IFwiaHR0cHM6Ly9zdGFuZWtzLmRlL2FwcHMvbWQybW9iaS9cIixcclxuXHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW5kbGUgZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdHNldHRpbmdzOiBLaW5kbGVQbHVnaW5TZXR0aW5ncztcclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBLaW5kbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5tZXJnZWRvd24gPT0gdHJ1ZSkge1x0XHRcclxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XHJcblx0XHRcdGlkOiAnTWVyZ2Vkb3duJyxcclxuXHRcdFx0bmFtZTogJ01lcmdlZG93bicsXHJcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0bGV0IEluaGFsdDogc3RyaW5nID0gXCJcIjtcclxuXHRcdFx0XHRsZXQgaW1hZ2VsaXN0OiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0XHRcdGxldCBpbWFnZW5hbWU6IHN0cmluZ1tdID0gW107XHJcblx0XHRcdFx0bGV0IGxpbmtzOiBBcnJheSA8IHN0cmluZyA+ID0gW107XHJcblx0XHRcdFx0bGV0IGxhbmcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImxhbmd1YWdlXCIpO1xyXG5cdFx0XHRcdGxldCBkb2t1bWVudCA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblx0XHRcdFx0aWYgKGRva3VtZW50ID09IG51bGwgfHwgZG9rdW1lbnQuZXh0ZW5zaW9uICE9IFwibWRcIikge1xyXG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1Mjc0QyBObyBhY3RpdmUgLm1kIGZpbGUuIFBsZWFzZSBvcGVuIGEgLm1kIGZpbGUgZmlyc3QhXCIpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsZXQgQWxsbGlua3MgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLnJlc29sdmVkTGlua3NbZG9rdW1lbnQucGF0aF07XHJcblx0XHRcdFx0bGlua3MgPSBPYmplY3QuZW50cmllcyhBbGxsaW5rcyk7XHJcblx0XHRcdFx0bGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGRva3VtZW50KVxyXG5cdFx0XHRcdGRhdGEgPSBkYXRhLnJlcGxhY2UoL11dL2csIFwiXV1cXG5cIik7XHJcblx0XHRcdFx0bGV0IGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKVxyXG5cdFx0XHRcdGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLk1lcmdlZG93bihsaW5lcywgSW5oYWx0LCBpbWFnZWxpc3QsIGltYWdlbmFtZSwgbGlua3MpO1xyXG5cdFx0XHRcdEluaGFsdCA9IHJlc3VsdC5JbmhhbHQ7XHJcblx0XHRcdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoLyUlW1xcc1xcU10qPyUlL2csIFwiXCIpO1xyXG5cdFx0XHRcdEluaGFsdCA9IEluaGFsdC5yZXBsYWNlKFwiXFxuXV1cIiwgXCJcIik7XHJcblx0XHRcdFx0bGV0IHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHRcdFx0XHRsZXQgZXhwYXRoID0gdGhpcy5zZXR0aW5ncy5leHBhdGg7XHJcblx0XHRcdFx0dGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKGV4cGF0aCk7XHJcblx0XHRcdFx0dGhpcy5hcHAudmF1bHQuY3JlYXRlKGV4cGF0aCArJy8nKyBkb2t1bWVudC5iYXNlbmFtZSArICdfbWVyZ2Vkb3duXycrdGltZSsnLm1kJywgSW5oYWx0KTtcclxuXHRcdFx0XHRpZiAobGFuZyA9PSBcImRlXCIpIHtcclxuXHRcdFx0XHRuZXcgTm90aWNlKFwiXHUyNzE0XHVGRTBGIE1lcmdlZG93biBlcmZvbGdyZWljaCFcIik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRuZXcgTm90aWNlKFwiXHUyNzE0XHVGRTBGIE1lcmdlZG93biBzdWNjZXNzZnVsIVwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cclxuXHJcblxyXG5cdFx0XHR9fSk7XHJcblx0XHR9XHJcblxyXG5cclxuXHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogJ0V4cG9ydCcsXHJcblx0XHRcdG5hbWU6ICdFeHBvcnQnLFxyXG5cdFx0XHRjYWxsYmFjazogKCkgPT4ge1xyXG5cdFx0XHRcdHRoaXMuZXhwb3J0KCk7XHJcblx0XHRcdCAgfSxcclxuXHRcdFx0fSk7XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MucmliYm9uaWNvbiA9PSB0cnVlKSB7XHRcclxuXHRcdFx0dGhpcy5hZGRSaWJib25JY29uKFwicGFwZXItcGxhbmVcIiwgXCJzZW5kMkUtUmVhZGVyXCIsICgpID0+IHtcclxuXHRcdFx0XHR0aGlzLmV4cG9ydCgpO1xyXG5cdFx0XHQgIH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdH1cclxuXHRhc3luYyBsb2FkU2V0dGluZ3MoKSB7XHJcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxuXHJcblxyXG5cdGFzeW5jIGdldEZpbGUodGV4dDogc3RyaW5nLCBsaW5rczogQXJyYXkgPCBzdHJpbmcgPiApIHtcclxuXHRcdGlmICh0ZXh0LmNvbnRhaW5zKFwiIVtbXCIpICYmIHRleHQuY29udGFpbnMoXCJdXVwiKSkge1xyXG5cdFx0bGV0IHN0YXJ0ID0gdGV4dC5pbmRleE9mKCchW1snKTtcclxuXHRcdGxldCBlbmQgPSB0ZXh0LmluZGV4T2YoJ11dJywgc3RhcnQgKyAzKTtcclxuXHRcdGxldCBuYW1lID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQgKyAzLCBlbmQpO1xyXG5cdFx0bmFtZSA9IFwiIVtbXCIgKyBuYW1lICsgXCJdXVwiO1xyXG5cdFx0XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZm91bmRMaW5rID0gbGlua3NbaV1bMF07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgY2h1bmsgPSBmb3VuZExpbmsuc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgXHJcblx0XHRcdGZvdW5kTGluaz0gY2h1bmtbY2h1bmsubGVuZ3RoIC0gMV07XHJcblx0XHRcdGxldCBleHRlbnNpb24gPSBmb3VuZExpbmsuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgZm91bmRMaW5rID0gZXh0ZW5zaW9uWzBdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKG5hbWUuY29udGFpbnMoZm91bmRMaW5rKSkgeyBcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbGlua3NbaV1bMF07XHJcblxyXG5cdFx0XHRcdHJldHVybiBbZmlsZSwgbmFtZV07XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZXtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRpZiAobGFuZyA9PSBcImRlXCIpIHtcclxuXHRcdFx0bmV3IE5vdGljZSgnXHUyNzRDIERlaW4gRG9rdW1lbnQgZW50aFx1MDBFNGx0IHVuYXVmZ2VsXHUwMEY2c3RlIERhdGVpZW4uIEJpdHRlIGtvcnJpZ2llcmUgZGFzIScpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmV3IE5vdGljZSgnXHUyNzRDIFlvdXIgZG9jdW1lbnQgY29udGFpbnMgdW5yZXNvbHZlZCBmaWxlcy4gUGxlYXNlIGZpeCBpdCEnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcbn1cclxuXHJcblx0YXN5bmMgR2V0RWJvb2sobGluZXM6IHN0cmluZ1tdLCBJbmhhbHQ6IHN0cmluZywgaW1hZ2VsaXN0OiBzdHJpbmdbXSwgaW1hZ2VuYW1lOiBzdHJpbmdbXSwgbGlua3M6IEFycmF5IDwgc3RyaW5nID4gKSB7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0ZXh0ID0gbGluZXNbaV07XHJcblx0XHRcdFxyXG5cclxuXHRcdFx0XHJcblx0XHRcdGlmICh0ZXh0LmNvbnRhaW5zKCchW1snKSAmJiB0ZXh0LmNvbnRhaW5zKCddXScpIHx8IHRleHQuY29udGFpbnMoJyFbJykgJiYgdGV4dC5jb250YWlucygnKScpICEmJiB0ZXh0LmNvbnRhaW5zKCdodHRwOi8vJykgISYmIHRleHQuY29udGFpbnMoJ2h0dHBzOi8vJykpIHtcclxuXHJcblx0XHRcdFx0bGV0IGZpbGUgPSBhd2FpdCB0aGlzLmdldEZpbGUodGV4dCwgbGlua3MpO1xyXG5cdFx0XHRcdGxldCBGaWxlTGluayA9IGZpbGVbMV07XHJcblx0XHRcdFx0ZmlsZSA9IGZpbGVbMF07XHJcbiAgICAgICAgICAgICAgICBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGUpO1xyXG5cdFx0XHRcdGlmIChmaWxlID09IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCkpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0bmV3IE5vdGljZSgnXHUyNzRDIFlvdSBjYW4gbm90IGVtYmVkIHRoZSBmaWxlIGluIGhpcyBvd24gZmlsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluIHRoZSBNb21lbnQgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGVtYmVkIHRoZSBmaWxlIGluIGhpcyBvd24gZmlsZVwiKTsgXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZmlsZS5leHRlbnNpb24gPT0gXCJwbmdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImpwZ1wiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwianBlZ1wiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwiZ2lmXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJzdmdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImJtcFwiKSB7XHJcblx0XHRcdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWRCaW5hcnkoZmlsZSk7XHJcblx0XHRcdFx0XHRsZXQgYmFzZTY0ID0gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG5cdFx0XHRcdFx0dmFyIGZpbGVuYW1lID0gZmlsZS5uYW1lLnJlcGxhY2UoL1teYS16MC05XS9naSwgJ18nKS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRcdFx0aW1hZ2VuYW1lLnB1c2goZmlsZW5hbWUpO1xyXG5cdFx0XHRcdFx0aW1hZ2VsaXN0LnB1c2goYmFzZTY0KTtcclxuXHRcdFx0XHRcdEluaGFsdCArPSAnXFxuPHA+PGltZyBjbGFzcz1cImludGVyblwiIHNyYz1cInVwbG9hZHMvJyArIGZpbGVuYW1lICsgJ1wiPjwvcD4nICsgJ1xcblxcbic7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZmlsZS5leHRlbnNpb24gPT0gXCJtcDNcIikge1xyXG5cdFx0XHRcdFx0bGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkQmluYXJ5KGZpbGUpO1xyXG5cdFx0XHRcdFx0bGV0IGJhc2U2NCA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuXHRcdFx0XHRcdHZhciBmaWxlbmFtZSA9IGZpbGUubmFtZS5yZXBsYWNlKC9bXmEtejAtOV0vZ2ksICdfJykudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRcdGltYWdlbmFtZS5wdXNoKGZpbGVuYW1lKTtcclxuXHRcdFx0XHRcdGltYWdlbGlzdC5wdXNoKGJhc2U2NCk7XHJcblx0XHRcdFx0XHRJbmhhbHQgKz0gJ1xcbjxwPjxhdWRpbyBjbGFzcz1cImludGVyblwiIHR5cGU9XCJhdWRpby9tcGVnXCIgc3JjPVwidXBsb2Fkcy8nICsgZmlsZW5hbWUgKyAnXCIgY29udHJvbHM9XCJjb250cm9sc1wiLz48L3A+JyArICdcXG5cXG4nO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGZpbGUuZXh0ZW5zaW9uID09ICdtZCcpIHtcclxuXHRcdFx0XHRcdGxldCBsaW5rczI6IEFycmF5IDwgc3RyaW5nID4gPSBbXTtcclxuXHRcdFx0XHRcdGxldCBkYXRhID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcclxuXHRcdFx0XHRcdHRleHQgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygndXRmOCcpO1xyXG5cdFx0XHRcdFx0aWYgKHRleHQuc3RhcnRzV2l0aCgnLS0tJykpIHtcclxuXHRcdFx0XHRcdFx0bGV0IHN0YXJ0ID0gdGV4dC5pbmRleE9mKCctLS0nKTtcclxuXHRcdFx0XHRcdFx0bGV0IGVuZCA9IHRleHQuaW5kZXhPZignLS0tJywgc3RhcnQgKyAzKTtcclxuXHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKGVuZCArIDMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0XHRcdFx0bGV0IGhlYWRpbmcgPSBcIlwiO1xyXG5cdFx0XHRcdFx0bGV0IEl0ZXJhdGlvbiA9IDA7IC8vU2V0IEl0ZXJhdGlvbmNvdW50ZXIgZm9yIGVhY2ggTGluayAoQ2FuJ3QgYnJlYWsgaXRlcmF0ZVJlZmVyZW5jZXMpXHJcblx0XHRcdFx0XHR0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLml0ZXJhdGVSZWZlcmVuY2VzKChzb3VyY2VQYXRoOiBzdHJpbmcsIHJlZmVyZW5jZTogUmVmZXJlbmNlQ2FjaGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZS5saW5rLmNvbnRhaW5zKGZpbGUuYmFzZW5hbWUpICYmIHJlZmVyZW5jZS5vcmlnaW5hbCA9PSBGaWxlTGluayAmJiBJdGVyYXRpb24gPT0gMCkge1xyXG5cdFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRcdFx0XHRcdGxldCBhbmtlciA9IHJlZmVyZW5jZS5saW5rLnNwbGl0KCcjJyk7XHJcblx0XHRcdFx0XHRcdFx0bGV0IGFua2VyU3BsaXQgPSBhbmtlci5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHRcdFx0XHRcdFx0XHRhbmtlciA9IGFua2VyW2Fua2VyLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdFx0XHRcdGhlYWRpbmcgPSAnPGgzPjxpPicgKyByZWZlcmVuY2UuZGlzcGxheVRleHQgKyAnPC9pPjwvaDM+XFxuJztcclxuXHRcdFxyXG5cdFx0XHRcdFx0XHRcdGlmIChhbmtlciAhPSB1bmRlZmluZWQgJiYgYW5rZXJTcGxpdCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChhbmtlci5jb250YWlucyhcIl5cIikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBhbmtlcmNhcmV0ID0gdGV4dC5pbmRleE9mKGFua2VyKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIGFua2VyY2FyZXQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcodGV4dC5sYXN0SW5kZXhPZihcIlxcblwiKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGhlYWRpbmcgPSAnJztcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBwb3MgPSB0ZXh0LmluZGV4T2YoYW5rZXIpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAocG9zID09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKHBvcyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKHBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGFua2VyLCAnJyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgcG9zMiA9IHRleHQuaW5kZXhPZignXFxuIycsIDEwKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBvczIgPT0gLTEpIHt9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBwb3MyKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdGlvbisrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHJcblxyXG5cdFx0XHRcdFx0dGV4dCA9IGhlYWRpbmcgKyB0ZXh0O1xyXG5cdFx0XHRcdFx0bGV0IGxpbmVzMiA9IHRleHQuc3BsaXQoXCJcXG5cIik7XHJcblxyXG5cdFx0XHRcdFx0bGV0IG5leHRtZCA9IGF3YWl0IHRoaXMuR2V0RWJvb2sobGluZXMyLCBJbmhhbHQsIGltYWdlbGlzdCwgaW1hZ2VuYW1lLCBsaW5rczIpO1xyXG5cdFx0XHRcdFx0SW5oYWx0ID0gbmV4dG1kLkluaGFsdDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmICh0ZXh0LmNvbnRhaW5zKCchWycpICYmIHRleHQuY29udGFpbnMoJyknKSAmJiB0ZXh0LmNvbnRhaW5zKCdodHRwOi8vJykgfHwgdGV4dC5jb250YWlucygnIVsnKSAmJiB0ZXh0LmNvbnRhaW5zKCcpJykgJiYgdGV4dC5jb250YWlucygnaHR0cHM6Ly8nKSkge1xyXG5cdFx0XHRcdFx0Ly8gZ2V0IHRleHQgYmV0d2VlbiAoKVxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRsZXQgSW1hZ2VMaW5rID0gdGV4dC5zdWJzdHJpbmcodGV4dC5pbmRleE9mKCcoJykgKyAxLCB0ZXh0LmluZGV4T2YoJyknKSk7XHJcblx0XHRcdFx0XHRJbmhhbHQgKz0gJzxwPjxpbWcgY2xhc3M9XCJleHRlcm5cIiBzcmM9XCInICsgSW1hZ2VMaW5rICsgJ1wiPjwvcD4gXFxuXFxuJztcclxuXHRcdFx0XHR9IFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0SW5oYWx0ICs9IHRleHQgKyBcIiBcXG5cXG5cIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFxyXG5cdFx0XHJcblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRJbmhhbHQsXHJcblx0XHRcdGltYWdlbGlzdCxcclxuXHRcdFx0aW1hZ2VuYW1lXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGV4cG9ydCgpIHtcclxuXHRcdGxldCBJbmhhbHQ6IHN0cmluZyA9IFwiXCI7XHJcblx0XHRsZXQgaW1hZ2VsaXN0OiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0bGV0IGltYWdlbmFtZTogc3RyaW5nW10gPSBbXTtcclxuXHRcdGxldCBsaW5rczogQXJyYXkgPCBzdHJpbmcgPiA9IFtdO1xyXG5cdFx0bGV0IGxhbmcgPSAnZW4nO1xyXG5cdFx0aWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsYW5ndWFnZScpICE9PSBudWxsKXtcclxuXHRcdFx0bGFuZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibGFuZ3VhZ2VcIik7XHJcblx0XHR9XHJcblx0XHRsZXQgZG9rdW1lbnQgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG5cdFx0aWYgKGRva3VtZW50ID09IG51bGwgfHwgZG9rdW1lbnQuZXh0ZW5zaW9uICE9IFwibWRcIikge1xyXG5cdFx0XHRuZXcgTm90aWNlKFwiXHUyNzRDIE5vIGFjdGl2ZSAubWQgZmlsZS4gUGxlYXNlIG9wZW4gYSAubWQgZmlsZSBmaXJzdCFcIik7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblxyXG5cclxuXHJcblx0XHR9XHJcblxyXG4gICAgICAgIGxldCBBbGxsaW5rcyA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUucmVzb2x2ZWRMaW5rc1tkb2t1bWVudC5wYXRoXTtcclxuICAgICAgICBsaW5rcyA9IE9iamVjdC5lbnRyaWVzKEFsbGxpbmtzKTtcclxuXHRcdGxldCBkYXRhID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY2FjaGVkUmVhZChkb2t1bWVudClcclxuXHRcdGlmIChkYXRhLnN0YXJ0c1dpdGgoJy0tLScpKSB7XHJcblx0XHRcdGxldCBzdGFydCA9IGRhdGEuaW5kZXhPZignLS0tJyk7XHJcblx0XHRcdGxldCBlbmQgPSBkYXRhLmluZGV4T2YoJy0tLScsIHN0YXJ0ICsgMyk7XHJcblx0XHRcdGRhdGEgPSBkYXRhLnN1YnN0cmluZyhlbmQgKyAzKTtcclxuXHRcdH1cclxuXHRcdGRhdGEgPSBkYXRhLnJlcGxhY2UoL11dL2csIFwiXV1cXG5cIik7XHJcblx0XHRsZXQgbGluZXMgPSBkYXRhLnNwbGl0KFwiXFxuXCIpXHJcblx0XHRsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5HZXRFYm9vayhsaW5lcywgSW5oYWx0LCBpbWFnZWxpc3QsIGltYWdlbmFtZSwgbGlua3MpO1xyXG5cdFx0SW5oYWx0ID0gcmVzdWx0LkluaGFsdDtcclxuXHRcdGltYWdlbGlzdCA9IHJlc3VsdC5pbWFnZWxpc3Q7XHJcblx0XHRpbWFnZW5hbWUgPSByZXN1bHQuaW1hZ2VuYW1lO1xyXG5cdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoLyUlW1xcc1xcU10qPyUlL2csIFwiXCIpO1xyXG5cdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoL2BgYGRhdGF2aWV3anNbXFxzXFxTXSo/YGBgL2csIFwiXCIpO1xyXG5cdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoLz09W1xcc1xcU10qPz09L2csIFwiPHU+JCY8L3U+XCIpO1xyXG5cdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoLz09L2csIFwiXCIpO1xyXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MucGFnZWJyZWFrID09IHRydWUpIHtcclxuXHRcdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoLy0tLS9nLCAnLS0tXFxuPHA+PGRpdiBzdHlsZT1cInBhZ2UtYnJlYWstYWZ0ZXI6IGFsd2F5cztcIj48L2Rpdj48L3A+XFxuJyk7fVxyXG5cdFx0XHRlbHNle1xyXG5cdFx0XHR9IFxyXG5cdFx0bGV0IGhvc3QgPSB0aGlzLnNldHRpbmdzLnNtdHBob3N0O1xyXG5cdFx0bGV0IHBvcnQgPSB0aGlzLnNldHRpbmdzLnBvcnQ7XHJcblx0XHRsZXQgcGFzcyA9IHRoaXMuc2V0dGluZ3MucGFzcztcclxuXHRcdGxldCBraW5kbGVtYWlsID0gdGhpcy5zZXR0aW5ncy5raW5kbGVtYWlsO1xyXG5cdFx0bGV0IHNlbmRtYWlsID0gdGhpcy5zZXR0aW5ncy5zZW5kbWFpbDtcclxuXHRcdGxldCBhdXRob3IgPSB0aGlzLnNldHRpbmdzLmF1dGhvcjtcclxuXHRcdGxldCB1c2VyID0gdGhpcy5zZXR0aW5ncy51c2VyO1xyXG5cdFx0bGV0IHRvYyA9IHRoaXMuc2V0dGluZ3MudG9jO1xyXG5cdFx0bGV0IGJhY2tlbmQgPSB0aGlzLnNldHRpbmdzLmJhY2tlbmQ7XHJcblx0XHRpZiAoaG9zdCA9PSBcIlwiIHx8IHBvcnQgPT0gXCJcIiB8fCBwYXNzID09IFwiXCIgfHwga2luZGxlbWFpbCA9PSBcIlwiIHx8IHNlbmRtYWlsID09IFwiXCIgfHwgYXV0aG9yID09IFwiXCIgfHwgdXNlciA9PSBcIlwiIHx8IGJhY2tlbmQgPT0gXCJcIikge1xyXG5cdFx0XHRpZiAobGFuZyA9PSBcImRlXCIpIHtcclxuXHRcdFx0XHRuZXcgTm90aWNlKFwiQml0dGUgZXJnXHUwMEU0bnplIGRpZSBFaW5zdGVsbHVuZ2VuLlwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRuZXcgTm90aWNlKFwiUGxlYXNlIGZpbGwgaW4gdGhlIHNldHRpbmdzIVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZiAobGFuZyA9PSBcImRlXCIpIHtcclxuXHRcdFx0bmV3IE5vdGljZSgnXHVEODNEXHVERTAzIERlaW4gRG9rdW1lbnQgJyArIGRva3VtZW50LmJhc2VuYW1lICsgJyB3aXJkIG51biBleHBvcnRpZXJ0LicpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmV3IE5vdGljZSgnXHVEODNEXHVERTAzIFlvdXIgTm90ZSAnICsgZG9rdW1lbnQuYmFzZW5hbWUgKyAnIGlzIGJlaW5nIGNvbnZlcnRlZCB0byBhbiBlYm9vaycpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHVybCA9IHRoaXMuc2V0dGluZ3MuYmFja2VuZDtcclxuXHRcdHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZWxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Zm9ybURhdGEuYXBwZW5kKCdmaWxlJyArIGksIGltYWdlbGlzdFtpXSk7XHJcblx0XHRcdFxyXG5cdFx0XHRcclxuXHRcdH1cclxuXHRcdC8vIENvdmVyYmlsZCB0b0RvXHJcblx0XHQvLyBmb3JtRGF0YS5hcHBlbmQoJ2NvdmVyJywgYmFzZTY0Y292ZXIpO1xyXG5cdFx0Ly8gZ2V0IGxhbmd1YWdlXHJcblx0XHRmb3JtRGF0YS5hcHBlbmQoJ2xhbmcnLCBsYW5nKTtcclxuXHRcdGZvcm1EYXRhLmFwcGVuZCgnQmlsZGVyJywgaW1hZ2VuYW1lKTtcclxuXHRcdGZvcm1EYXRhLmFwcGVuZCgndGV4dCcsICcjJyArIGRva3VtZW50LmJhc2VuYW1lICsgJ1xcbicgKyBJbmhhbHQpO1xyXG5cdFx0Zm9ybURhdGEuYXBwZW5kKCd0aXRsZScsIGRva3VtZW50LmJhc2VuYW1lKTtcclxuXHRcdGZvcm1EYXRhLmFwcGVuZCgnYXV0aG9yJywgYXV0aG9yKTtcclxuXHRcdGZvcm1EYXRhLmFwcGVuZCgnZW1haWwnLCBzZW5kbWFpbCk7XHJcblx0XHRmb3JtRGF0YS5hcHBlbmQoJ2tpbmRsZScsIGtpbmRsZW1haWwpO1xyXG5cdFx0Zm9ybURhdGEuYXBwZW5kKCdwb3J0JywgcG9ydCk7XHJcblx0XHRmb3JtRGF0YS5hcHBlbmQoJ2hvc3QnLCBob3N0KTtcclxuXHRcdGZvcm1EYXRhLmFwcGVuZCgncGFzcycsIHBhc3MpO1xyXG5cdFx0Zm9ybURhdGEuYXBwZW5kKCd1c2VyJywgdXNlcik7XHJcblx0XHRmb3JtRGF0YS5hcHBlbmQoJ3RvYycsIHRvYyk7XHJcblx0XHRhd2FpdCBmZXRjaCh1cmwsIHtcclxuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0XHRib2R5OiBmb3JtRGF0YSxcclxuXHRcdFx0fSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24gKGJvZHkpIHtcclxuXHRcdFx0XHRuZXcgTm90aWNlKGJvZHkpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuY2F0Y2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShcIlx1Mjc0QyBJbnRlcm5ldGNvbm5lY3Rpb24gZXJyb3Igb3IgU2VydmVyIGlzIG9mZmxpbmVcIik7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cclxuLy8gTWVyZ2Vkb3duIEZlYXR1cmUgKEkga25vdyB0aGUgRFJZIE1ldGhvZCBidXQgaXQgd2FzIG1vcmUgZWFzeSB0byBjb3B5ICYgcGFzdGUpXHJcblxyXG5cclxuXHRcdGFzeW5jIE1lcmdlZG93bihsaW5lczogc3RyaW5nW10sIEluaGFsdDogc3RyaW5nLCBpbWFnZWxpc3Q6IHN0cmluZ1tdLCBpbWFnZW5hbWU6IHN0cmluZ1tdLCBsaW5rczogQXJyYXkgPCBzdHJpbmcgPiApIHtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGxldCB0ZXh0ID0gbGluZXNbaV07XHJcblx0XHRcdFx0XHJcblx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHRleHQuY29udGFpbnMoJyFbWycpICYmIHRleHQuY29udGFpbnMoJ11dJykgfHwgdGV4dC5jb250YWlucygnIVsnKSAmJiB0ZXh0LmNvbnRhaW5zKCcpJykgISYmIHRleHQuY29udGFpbnMoJ2h0dHA6Ly8nKSAhJiYgdGV4dC5jb250YWlucygnaHR0cHM6Ly8nKSkge1xyXG5cdFxyXG5cdFx0XHRcdFx0bGV0IGZpbGUgPSBhd2FpdCB0aGlzLmdldEZpbGUodGV4dCwgbGlua3MpO1xyXG5cdFx0XHRcdFx0bGV0IEZpbGVMaW5rID0gZmlsZVsxXTtcclxuXHRcdFx0XHRcdGZpbGUgPSBmaWxlWzBdO1xyXG4gICAgICAgICAgICAgICAgXHRmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGUpO1xyXG5cdFx0XHRcdFx0aWYgKGZpbGUgPT0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKSlcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnXHUyNzRDIFlvdSBjYW4gbm90IGVtYmVkIHRoZSBmaWxlIGluIGhpcyBvd24gZmlsZScpO1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbiB0aGUgTW9tZW50IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBlbWJlZCB0aGUgZmlsZSBpbiBoaXMgb3duIGZpbGVcIik7IFxyXG5cdFx0XHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRcdFx0aWYgKGZpbGUuZXh0ZW5zaW9uID09IFwicG5nXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJqcGdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImpwZWdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImdpZlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwic3ZnXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJibXBcIikge1xyXG5cdFx0XHRcdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWRCaW5hcnkoZmlsZSk7XHJcblx0XHRcdFx0XHRcdGxldCBiYXNlNjQgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcblx0XHRcdFx0XHRcdGltYWdlbmFtZS5wdXNoKGZpbGUubmFtZSk7XHJcblx0XHRcdFx0XHRcdGltYWdlbGlzdC5wdXNoKGJhc2U2NCk7XHJcblx0XHRcdFx0XHRcdEluaGFsdCArPSAnXFxuIVsnKyBmaWxlLm5hbWUgKyddKGRhdGE6aW1hZ2UvJysgZmlsZS5leHRlbnNpb24rJztiYXNlNjQsJyArIGJhc2U2NCArICcpXFxuJztcclxuXHRcdFx0XHRcdH1cclxuXHRcclxuXHRcdFx0XHRcdGlmIChmaWxlLmV4dGVuc2lvbiA9PSBcIm1wNFwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwid2VibVwiICB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIm9ndlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwiYXZpXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJtb3ZcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIndtdlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwibXBnXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJtcGVnXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJta3ZcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImZsdlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwic3dmXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJ2b2JcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIm00dlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwibTRhXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJtNGJcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIm00clwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwiM2dwXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCIzZzJcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImY0dlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwiZjRhXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJmNGJcIikge1xyXG5cdFx0XHRcdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWRCaW5hcnkoZmlsZSk7XHJcblx0XHRcdFx0XHRcdGxldCBiYXNlNjQgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcblx0XHRcdFx0XHRcdEluaGFsdCArPSAnXFxuPHZpZGVvIGNvbnRyb2xzPjxzb3VyY2Ugc3JjPVwiZGF0YTp2aWRlby8nKyBmaWxlLmV4dGVuc2lvbisnO2Jhc2U2NCwnICsgYmFzZTY0ICsgJ1wiIHR5cGU9XCJ2aWRlby8nKyBmaWxlLmV4dGVuc2lvbisnXCI+PC92aWRlbz5cXG4nO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRcdFx0aWYgKGZpbGUuZXh0ZW5zaW9uID09IFwibXAzXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJvZ2dcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIndhdlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwiZmxhY1wiKSB7XHJcblx0XHRcdFx0XHRcdGxldCBkYXRhID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZEJpbmFyeShmaWxlKTtcclxuXHRcdFx0XHRcdFx0bGV0IGJhc2U2NCA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuXHRcdFx0XHRcdFx0SW5oYWx0ICs9ICdcXG48YXVkaW8gY29udHJvbHM+PHNvdXJjZSBzcmM9XCJkYXRhOmF1ZGlvLycrIGZpbGUuZXh0ZW5zaW9uKyc7YmFzZTY0LCcgKyBiYXNlNjQgKyAnXCIgdHlwZT1cImF1ZGlvLycrIGZpbGUuZXh0ZW5zaW9uKydcIj48L2F1ZGlvPlxcbic7XHJcblx0XHRcdFx0XHR9XHJcblx0XHJcblx0XHJcblx0XHRcdFx0XHRpZiAoZmlsZS5leHRlbnNpb24gPT0gJ21kJykge1xyXG5cdFx0XHRcdFx0XHRsZXQgbGlua3MyOiBBcnJheSA8IHN0cmluZyA+ID0gW107XHJcblx0XHRcdFx0XHRcdGxldCBkYXRhID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuY2FjaGVkUmVhZChmaWxlKTtcclxuXHRcdFx0XHRcdFx0dGV4dCA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCd1dGY4Jyk7XHJcblx0XHRcdFx0XHRcdGlmICh0ZXh0LnN0YXJ0c1dpdGgoJy0tLScpKSB7XHJcblx0XHRcdFx0XHRcdFx0bGV0IHN0YXJ0ID0gdGV4dC5pbmRleE9mKCctLS0nKTtcclxuXHRcdFx0XHRcdFx0XHRsZXQgZW5kID0gdGV4dC5pbmRleE9mKCctLS0nLCBzdGFydCArIDMpO1xyXG5cdFx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZyhlbmQgKyAzKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdFx0XHRcdFx0XHRsZXQgaGVhZGluZyA9IFwiXCI7XHJcblx0XHRcdFx0XHRcdGxldCBJdGVyYXRpb24gPSAwOyAvL1NldCBJdGVyYXRpb25jb3VudGVyIGZvciBlYWNoIExpbmsgKENhbid0IGJyZWFrIGl0ZXJhdGVSZWZlcmVuY2VzKVxyXG5cdFx0XHRcdFx0XHR0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLml0ZXJhdGVSZWZlcmVuY2VzKChzb3VyY2VQYXRoOiBzdHJpbmcsIHJlZmVyZW5jZTogUmVmZXJlbmNlQ2FjaGUpID0+IHtcclxuXHRcdFx0XHRcdFx0XHRpZiAocmVmZXJlbmNlLmxpbmsuY29udGFpbnMoZmlsZS5iYXNlbmFtZSkgJiYgcmVmZXJlbmNlLm9yaWdpbmFsID09IEZpbGVMaW5rICYmIEl0ZXJhdGlvbiA9PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBcclxuXHRcdFx0XHRcdFx0XHRcdGxldCBhbmtlciA9IHJlZmVyZW5jZS5saW5rLnNwbGl0KCcjJyk7XHJcblx0XHRcdFx0XHRcdFx0XHRsZXQgYW5rZXJTcGxpdCA9IGFua2VyLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdFx0YW5rZXIgPSBhbmtlclthbmtlci5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRcdFx0XHRcdGhlYWRpbmcgPSAnPGgzPjxpPicgKyByZWZlcmVuY2UuZGlzcGxheVRleHQgKyAnPC9pPjwvaDM+XFxuJztcclxuXHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoYW5rZXIgIT0gdW5kZWZpbmVkICYmIGFua2VyU3BsaXQgPiAxKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChhbmtlci5jb250YWlucyhcIl5cIikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsZXQgYW5rZXJjYXJldCA9IHRleHQuaW5kZXhPZihhbmtlcik7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIGFua2VyY2FyZXQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZyh0ZXh0Lmxhc3RJbmRleE9mKFwiXFxuXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRoZWFkaW5nID0gJyc7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bGV0IHBvcyA9IHRleHQuaW5kZXhPZihhbmtlcik7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBvcyA9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKHBvcyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKHBvcyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKGFua2VyLCAnJyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsZXQgcG9zMiA9IHRleHQuaW5kZXhPZignXFxuIycsIDEwKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAocG9zMiA9PSAtMSkge30gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgcG9zMik7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdEl0ZXJhdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcclxuXHRcclxuXHRcclxuXHRcdFx0XHRcdFx0dGV4dCA9IGhlYWRpbmcgKyB0ZXh0O1xyXG5cdFx0XHRcdFx0XHRsZXQgbGluZXMyID0gdGV4dC5zcGxpdChcIlxcblwiKTtcclxuXHRcclxuXHRcdFx0XHRcdFx0bGV0IG5leHRtZCA9IGF3YWl0IHRoaXMuTWVyZ2Vkb3duKGxpbmVzMiwgSW5oYWx0LCBpbWFnZWxpc3QsIGltYWdlbmFtZSwgbGlua3MyKTtcclxuXHRcdFx0XHRcdFx0SW5oYWx0ID0gbmV4dG1kLkluaGFsdDtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0aWYgKHRleHQuY29udGFpbnMoJyFbJykgJiYgdGV4dC5jb250YWlucygnKScpICYmIHRleHQuY29udGFpbnMoJ2h0dHA6Ly8nKSB8fCB0ZXh0LmNvbnRhaW5zKCchWycpICYmIHRleHQuY29udGFpbnMoJyknKSAmJiB0ZXh0LmNvbnRhaW5zKCdodHRwczovLycpKSB7XHJcblx0XHRcdFx0XHRcdC8vIGdldCB0ZXh0IGJldHdlZW4gKClcclxuXHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdEluaGFsdCArPSB0ZXh0ICsgXCJcXG5cIjtcclxuXHRcdFx0XHRcdH0gXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRcdFx0SW5oYWx0ICs9IHRleHQgKyBcIlxcblwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdFxyXG5cdFxyXG5cdFxyXG5cdFx0XHR9XHJcblx0XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0SW5oYWx0LFxyXG5cdFx0XHRcdGltYWdlbGlzdCxcclxuXHRcdFx0XHRpbWFnZW5hbWVcclxuXHRcdFx0fTtcclxuXHRcclxuXHRcdH1cclxuXHJcblxyXG5cclxufSIsICJpbXBvcnQgS2luZGxlUGx1Z2luIGZyb20gXCJtYWluXCI7XHJcbmltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEtpbmRsZVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuICBwbHVnaW46IEtpbmRsZVBsdWdpbjtcclxuXHJcbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogS2luZGxlUGx1Z2luKSB7XHJcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XHJcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICB9XHJcblxyXG4gIGRpc3BsYXkoKTogdm9pZCB7XHJcbiAgICBsZXQgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHJcbiAgICBjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIktpbmRsZSBzZXR0aW5nc1wiIH0pO1xyXG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogXCJTZXQgeW91ciBkYXRhIGZvciB5b3VyIEtpbmRsZS4gVXNlIHlvdXIgZW1haWwgd2hpY2ggaXMgYXBwcm92ZWQgYnkgQW1hem9uLlwiIH0pO1xyXG5cclxuXHJcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJBdXRob3JcIilcclxuICAgICAgLnNldERlc2MoXCJEZWZhdWx0IGF1dGhvciBmb3IgbmV3IGRvY3VtZW50c1wiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJPYnNpZGlhblwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dGhvcilcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0aG9yID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiRW1haWxcIilcclxuICAgICAgLnNldERlc2MoXCJBcHByb3ZlZCBFbWFpbCBmb3IgeW91ciBLaW5kbGVcIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwieW91QG9ic2lkaWFuLm1kXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VuZG1haWwpXHRcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VuZG1haWwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJLaW5kbGVtYWlsXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiWW91ciBLaW5kbGUvUG9ja2V0Qm9vayBlbWFpbFwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJ5b3VAa2luZGxlLmNvbVwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmtpbmRsZW1haWwpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmtpbmRsZW1haWwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJTTVRQIEhvc3RcIilcclxuICAgICAgLnNldERlc2MoXCJZb3VyIFNNVFAgaG9zdCAoZS5nLiBzbXRwLmdtYWlsLmNvbSlcIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwic210cC5vYnNpZGlhbi5tZFwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNtdHBob3N0KVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zbXRwaG9zdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlNNVFAgUG9ydFwiKVxyXG4gICAgICAuc2V0RGVzYyhcIllvdXIgU01UUCBwb3J0IChlLmcuIDU4NylcIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiNDY1XCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucG9ydClcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucG9ydCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiU01UUCBVc2VyXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiVXNlcm5hbWUgZm9yIHlvdXIgU01UUCBzZXJ2ZXIgZS5nLiB5b3VyIE1haWxhZHJlc3NcIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwieW91QG9ic2lkaWFuLm1kXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlcilcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudXNlciA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcblxyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiU01UUCBQYXNzd29yZFwiKVxyXG4gICAgICAuc2V0RGVzYyhcIllvdXIgU01UUCBwYXNzd29yZFwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCIqKioqKioqKlwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBhc3MpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnBhc3MgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJCYWNrZW5kXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiWW91ciBiYWNrZW5kYWRyZXNzIChlLmcuIGh0dHBzOi8vc3RhbmVrcy5kZS9hcHBzL21kMm1vYmkvKSBjYW4gYmUgdXNlZCBmb3IgZnJlZSBvciBob3N0IHlvdXIgb3duIEJhY2tlbmQuXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcImh0dHBzOi8vb2Iya2kuY29tXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYmFja2VuZClcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmFja2VuZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkdlbmVyYXRlIFRPQ1wiKVxyXG4gICAgICAuc2V0RGVzYyhcIkdlbmVyYXRlIFRhYmxlIG9mIENvbnRlbnRzLlwiKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XHJcbiAgICAgICAgdG9nZ2xlXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudG9jKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy50b2MgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaHJcIik7XHJcbiAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIlx1MkI1MCBTdWdnZXN0ZWQgZmVhdHVyZXNcIiB9KTtcclxuICAgICBcclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiUGFnZWJyZWFrIGJ5ICctLS0nXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiU3VnZ2VzdGVkIGZlYXR1cmU6IEFjdGl2YXRlIHBhZ2VicmVhayBieSAnLS0tJ1wiKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XHJcbiAgICAgICAgdG9nZ2xlXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucGFnZWJyZWFrKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wYWdlYnJlYWsgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJNYXJrZG93biBtZXJnZVwiKVxyXG4gICAgICAuc2V0RGVzYyhcIlN1Z2dlc3RlZCBmZWF0dXJlOiBNZXJnZSAubWQgZmlsZXMgaW50byBvbmUgZmlsZSAoYWRkcyBLaW5kbGU6IE1lcmdlZG93biBjb21tYW5kKSBQbHVnaW4gcmVsb2FkcyBhZnRlciBzYXZpbmcuXCIpXHJcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cclxuICAgICAgICB0b2dnbGVcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tZXJnZWRvd24pXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1lcmdlZG93biA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5wbHVnaW5zLnVubG9hZFBsdWdpbignb2JzaWRpYW4ta2luZGxlLWV4cG9ydCcpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5wbHVnaW5zLmxvYWRQbHVnaW4oJ29ic2lkaWFuLWtpbmRsZS1leHBvcnQnKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJFeHBvcnRwYXRoXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiU2V0IHRoZSBwYXRoIHdoZXJlIHlvdSB3YW50IHRvIGV4cG9ydCB5b3VyIGZpbGVzIHRvLiAoZS5nLiAvZm9sZGVyKVwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCIvZm9sZGVyXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhwYXRoKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leHBhdGggPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJBZGQgUmliYm9uLUljb25cIilcclxuICAgICAgLnNldERlc2MoXCJTdWdnZXN0ZWQgZmVhdHVyZTogQWRkIFJpYmJvbi1JY29uIGZvciB0aGUgRXhwb3J0LUNvbW1hbmQuIFBsdWdpbiByZWxvYWRzIGFmdGVyIHNhdmluZy5cIilcclxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxyXG4gICAgICAgIHRvZ2dsZVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJpYmJvbmljb24pXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJpYmJvbmljb249IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5wbHVnaW5zLnVubG9hZFBsdWdpbignb2JzaWRpYW4ta2luZGxlLWV4cG9ydCcpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5wbHVnaW5zLmxvYWRQbHVnaW4oJ29ic2lkaWFuLWtpbmRsZS1leHBvcnQnKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImhyXCIpO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBcIkhvc3QgeW91ciBvd24gT2JzaWRpYW4yS2luZGxlLUNvbnZlcnRlci5cIn0pO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImFcIiwgeyB0ZXh0OiBcIkZvcmsgZnJvbSBHaXRodWIgXHVEODNEXHVERDE3XCIsIGhyZWY6IFwiaHR0cHM6Ly9naXRodWIuY29tL1NpbWVvbkx1a2FzL09ic2lkaWFuMktpbmRsZVwifSk7XHJcbiAgICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiYnJcIik7XHJcblxyXG4gIFxyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImFcIiwgeyB0ZXh0OiBcIkJ1eSBtZSBhIFx1MjYxNVwiLCBocmVmOiBcImh0dHBzOi8vd3d3LmJ1eW1lYWNvZmZlZS5jb20vc2ltZW9ubHVrYXNcIn0pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgXHJcbiAgICB9XHJcbiAgICB9XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtB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
