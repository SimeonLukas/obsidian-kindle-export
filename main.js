/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// buffer/index.js
var require_buffer = __commonJS({
  "buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// main.ts
__export(exports, {
  default: () => Kindle
});
var import_buffer = __toModule(require_buffer());
var import_obsidian2 = __toModule(require("obsidian"));

// settings.ts
var import_obsidian = __toModule(require("obsidian"));
var KindleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Kindle settings" });
    containerEl.createEl("p", { text: "Set your data for your Kindle. Use your email which is approved by Amazon." });
    new import_obsidian.Setting(containerEl).setName("Author").setDesc("Default author for new documents").addText((text) => text.setPlaceholder("Obsidian").setValue(this.plugin.settings.author).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.author = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Email").setDesc("Approved Email for your Kindle").addText((text) => text.setPlaceholder("you@obsidian.md").setValue(this.plugin.settings.sendmail).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.sendmail = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Kindlemail").setDesc("Your Kindle email").addText((text) => text.setPlaceholder("you@kindle.com").setValue(this.plugin.settings.kindlemail).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.kindlemail = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Host").setDesc("Your SMTP host (e.g. smtp.gmail.com)").addText((text) => text.setPlaceholder("smtp.obsidian.md").setValue(this.plugin.settings.smtphost).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.smtphost = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Port").setDesc("Your SMTP port (e.g. 587)").addText((text) => text.setPlaceholder("465").setValue(this.plugin.settings.port).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.port = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP User").setDesc("Username for your SMTP server e.g. your Mailadress").addText((text) => text.setPlaceholder("you@obsidian.md").setValue(this.plugin.settings.user).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.user = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("SMTP Password").setDesc("Your SMTP password").addText((text) => text.setPlaceholder("********").setValue(this.plugin.settings.pass).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pass = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Backend").setDesc("Your backendadress (e.g. https://staneks.de/apps/md2mobi/) can be used for free or host your own Backend.").addText((text) => text.setPlaceholder("https://ob2ki.com").setValue(this.plugin.settings.backend).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.backend = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    containerEl.createEl("hr");
    containerEl.createEl("h1", { text: "\u2B50 Suggested features" });
    new import_obsidian.Setting(containerEl).setName("Pagebreak by '---'").setDesc("Suggested feature: Activate pagebreak by '---'").addToggle((toggle) => toggle.setValue(this.plugin.settings.pagebreak).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pagebreak = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    new import_obsidian.Setting(containerEl).setName("Markdown merge").setDesc("Suggested feature: Merge .md files into one file (adds Kindle: Mergedown command) Plugin reloads after saving.").addToggle((toggle) => toggle.setValue(this.plugin.settings.mergedown).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.mergedown = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
      this.app.plugins.unloadPlugin("obsidian-kindle-export");
      this.app.plugins.loadPlugin("obsidian-kindle-export");
    })));
    new import_obsidian.Setting(containerEl).setName("Exportpath").setDesc("Set the path where you want to export your files to. (e.g. /folder)").addText((text) => text.setPlaceholder("/folder").setValue(this.plugin.settings.expath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.expath = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    containerEl.createEl("hr");
    containerEl.createEl("p", { text: "Host your own Obsidian2Kindle-Converter." });
    containerEl.createEl("a", { text: "Fork from Github \u{1F517}", href: "https://github.com/SimeonLukas/Obsidian2Kindle" });
    containerEl.createEl("hr");
    containerEl.createEl("h1", { text: "\u23F3Beta Settings" });
    new import_obsidian.Setting(containerEl).setName("Generate TOC").setDesc("Generate Table of Contents. This is a beta feature and may not work correctly.").addToggle((toggle) => toggle.setValue(this.plugin.settings.toc).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.toc = value;
      yield this.plugin.saveSettings();
      console.log(this.plugin.settings);
    })));
    containerEl.createEl("hr");
    containerEl.createEl("a", { text: "Buy me a \u2615", href: "https://www.buymeacoffee.com/simeonlukas" });
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  author: "",
  sendmail: "",
  kindlemail: "",
  port: "",
  smtphost: "",
  pass: "",
  expath: "",
  backend: "https://staneks.de/apps/md2mobi/"
};
var Kindle = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new KindleSettingTab(this.app, this));
      if (this.settings.mergedown == true) {
        this.addCommand({
          id: "Mergedown",
          name: "Mergedown",
          callback: () => __async(this, null, function* () {
            let Inhalt = "";
            let imagelist = [];
            let imagename = [];
            let links = [];
            let lang2 = localStorage.getItem("language");
            let dokument = this.app.workspace.getActiveFile();
            if (dokument == null || dokument.extension != "md") {
              new import_obsidian2.Notice("\u274C No active .md file. Please open a .md file first!");
              return;
            }
            let AllLinks = this.app.fileManager.getAllLinkResolutions();
            for (let i = 0; i < AllLinks.length; i++) {
              if (AllLinks[i].sourceFile.path == dokument.path) {
                links.push(AllLinks[i]);
              }
            }
            let data = yield this.app.vault.cachedRead(dokument);
            let lines = data.split("\n");
            let result = yield this.Mergedown(lines, Inhalt, imagelist, imagename, links);
            Inhalt = result.Inhalt;
            Inhalt = Inhalt.replace(/%%[\s\S]*?%%/g, "");
            let time = new Date().getTime();
            let expath = this.settings.expath;
            this.app.vault.createFolder(expath);
            this.app.vault.create(expath + "/" + dokument.basename + "_mergedown_" + time + ".md", Inhalt);
            if (lang2 == "de") {
              new import_obsidian2.Notice("\u2714\uFE0F Mergedown erfolgreich!");
            } else {
              new import_obsidian2.Notice("\u2714\uFE0F Mergedown successful!");
            }
          })
        });
      }
      this.addCommand({
        id: "Export",
        name: "Export",
        callback: () => __async(this, null, function* () {
          let Inhalt = "";
          let imagelist = [];
          let imagename = [];
          let links = [];
          let lang2 = localStorage.getItem("language");
          let dokument = this.app.workspace.getActiveFile();
          if (dokument == null || dokument.extension != "md") {
            new import_obsidian2.Notice("\u274C No active .md file. Please open a .md file first!");
            return;
          }
          let AllLinks = this.app.fileManager.getAllLinkResolutions();
          for (let i = 0; i < AllLinks.length; i++) {
            if (AllLinks[i].sourceFile.path == dokument.path) {
              links.push(AllLinks[i]);
            }
          }
          let data = yield this.app.vault.cachedRead(dokument);
          if (data.startsWith("---")) {
            let start = data.indexOf("---");
            let end = data.indexOf("---", start + 3);
            data = data.substring(end + 3);
          }
          let lines = data.split("\n");
          let result = yield this.GetEbook(lines, Inhalt, imagelist, imagename, links);
          Inhalt = result.Inhalt;
          imagelist = result.imagelist;
          imagename = result.imagename;
          Inhalt = Inhalt.replace(/%%[\s\S]*?%%/g, "");
          Inhalt = Inhalt.replace(/```dataviewjs[\s\S]*?```/g, "");
          Inhalt = Inhalt.replace(/==[\s\S]*?==/g, "<u>$&</u>");
          Inhalt = Inhalt.replace(/==/g, "");
          if (this.settings.pagebreak == true) {
            Inhalt = Inhalt.replace(/---/g, '---\n<p><div style="page-break-after: always;"></div></p>\n');
          } else {
          }
          let host = this.settings.smtphost;
          let port = this.settings.port;
          let pass = this.settings.pass;
          let kindlemail = this.settings.kindlemail;
          let sendmail = this.settings.sendmail;
          let author = this.settings.author;
          let user = this.settings.user;
          let toc = this.settings.toc;
          let backend = this.settings.backend;
          if (host == "" || port == "" || pass == "" || kindlemail == "" || sendmail == "" || author == "" || user == "" || backend == "") {
            if (lang2 == "de") {
              new import_obsidian2.Notice("Bitte erg\xE4nze die Einstellungen.");
            } else {
              new import_obsidian2.Notice("Please fill in the settings!");
            }
            return;
          }
          if (lang2 == "de") {
            new import_obsidian2.Notice("\u{1F603} Dein Dokument " + dokument.basename + " wird nun exportiert.");
          } else {
            new import_obsidian2.Notice("\u{1F603} Your Note " + dokument.basename + " is being converted to an ebook");
          }
          var url = this.settings.backend;
          var formData = new FormData();
          for (let i = 0; i < imagelist.length; i++) {
            formData.append("file" + i, imagelist[i]);
            console.log(imagename[i]);
            console.log(imagelist[i]);
          }
          formData.append("lang", lang2);
          formData.append("Bilder", imagename);
          formData.append("text", Inhalt);
          formData.append("title", dokument.basename);
          formData.append("author", author);
          formData.append("email", sendmail);
          formData.append("kindle", kindlemail);
          formData.append("port", port);
          formData.append("host", host);
          formData.append("pass", pass);
          formData.append("user", user);
          formData.append("toc", toc);
          yield fetch(url, {
            method: "POST",
            body: formData
          }).then(function(response) {
            return response.text();
          }).then(function(body) {
            new import_obsidian2.Notice(body);
          }).catch(function() {
            new import_obsidian2.Notice("\u274C Internetconnection error or Server is offline");
          });
        })
      });
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  getFile(text, links) {
    return __async(this, null, function* () {
      if (text.contains("![[") && text.contains("]]")) {
        let start = text.indexOf("![[");
        let end = text.indexOf("]]", start + 3);
        let name = text.substring(start + 3, end);
        name = "![[" + name + "]]";
        console.log(name);
        for (let i = 0; i < links.length; i++) {
          if (links[i].reference.original == name) {
            console.log(links[i].reference.original);
            var file = links[i];
            return file;
          } else {
            console.log("nicht gefunden");
          }
        }
      } else {
        if (lang == "de") {
          new import_obsidian2.Notice("\u274C Dein Dokument enth\xE4lt unaufgel\xF6ste Dateien. Bitte korrigiere das!");
        } else {
          new import_obsidian2.Notice("\u274C Your document contains unresolved files. Please fix it!");
        }
        return null;
      }
    });
  }
  GetEbook(lines, Inhalt, imagelist, imagename, links) {
    return __async(this, null, function* () {
      for (let i = 0; i < lines.length; i++) {
        let text = lines[i];
        if (text.contains("![[") && text.contains("]]") || text.contains("![") && text.contains(")") && text.contains("http://") && text.contains("https://")) {
          let file = yield this.getFile(text, links);
          let LinkFile = file;
          file = file.resolvedFile;
          if (file.extension == "png" || file.extension == "jpg" || file.extension == "jpeg" || file.extension == "gif" || file.extension == "svg" || file.extension == "bmp") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            imagename.push(file.name);
            imagelist.push(base64);
            Inhalt += '\n<p><img class="intern" src="uploads/' + file.name + '"></p>\n\n';
          }
          if (file.extension == "md") {
            let links2 = [];
            let data = yield this.app.vault.cachedRead(file);
            text = import_buffer.Buffer.from(data).toString("utf8");
            if (text.startsWith("---")) {
              let start = text.indexOf("---");
              let end = text.indexOf("---", start + 3);
              text = text.substring(end + 3);
            }
            let ankers = LinkFile.reference.link.split("#");
            console.log(ankers);
            let anker = ankers[ankers.length - 1];
            let heading = "<h3><i>" + LinkFile.reference.displayText + "</i></h3>\n\n";
            if (ankers.length > 1) {
              if (anker.contains("^")) {
                console.log(anker);
                let ankercaret = text.indexOf(anker);
                text = text.substring(0, ankercaret);
                text = text.substring(text.lastIndexOf("\n\n"));
                heading = "";
              } else {
                let pos = text.indexOf(anker);
                if (pos == -1) {
                  text = text.substring(pos);
                } else {
                  text = text.substring(pos + anker.length);
                }
                let pos2 = text.indexOf("\n#", 30);
                if (pos2 == -1) {
                } else {
                  text = text.substring(0, pos2);
                }
              }
            }
            text = heading + text;
            let AllLinks2 = this.app.fileManager.getAllLinkResolutions();
            for (let i2 = 0; i2 < AllLinks2.length; i2++) {
              if (AllLinks2[i2].sourceFile.path == file.path) {
                links2.push(AllLinks2[i2]);
              }
            }
            let lines2 = text.split("\n");
            let nextmd = yield this.GetEbook(lines2, Inhalt, imagelist, imagename, links2);
            Inhalt = nextmd.Inhalt;
          } else {
          }
        } else {
          if (text.contains("![") && text.contains(")") && text.contains("http://") || text.contains("![") && text.contains(")") && text.contains("https://")) {
            console.log("EXTERN");
            let ImageLink = text.substring(text.indexOf("(") + 1, text.indexOf(")"));
            Inhalt += '<p><img class="extern" src="' + ImageLink + '"></p> \n\n';
          } else {
            Inhalt += text + " \n\n";
          }
        }
      }
      return {
        Inhalt,
        imagelist,
        imagename
      };
    });
  }
  Mergedown(lines, Inhalt, imagelist, imagename, links) {
    return __async(this, null, function* () {
      for (let i = 0; i < lines.length; i++) {
        let text = lines[i];
        if (text.contains("![[") && text.contains("]]") || text.contains("![") && text.contains(")") && text.contains("http://") && text.contains("https://")) {
          let file = yield this.getFile(text, links);
          let LinkFile = file;
          file = file.resolvedFile;
          if (file.extension == "png" || file.extension == "jpg" || file.extension == "jpeg" || file.extension == "gif" || file.extension == "svg" || file.extension == "bmp") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            imagename.push(file.name);
            imagelist.push(base64);
            Inhalt += "\n![" + file.name + "](data:image/" + file.extension + ";base64," + base64 + ")\n";
          }
          if (file.extension == "mp4" || file.extension == "webm" || file.extension == "ogv" || file.extension == "avi" || file.extension == "mov" || file.extension == "wmv" || file.extension == "mpg" || file.extension == "mpeg" || file.extension == "mkv" || file.extension == "flv" || file.extension == "swf" || file.extension == "vob" || file.extension == "m4v" || file.extension == "m4a" || file.extension == "m4b" || file.extension == "m4r" || file.extension == "3gp" || file.extension == "3g2" || file.extension == "f4v" || file.extension == "f4a" || file.extension == "f4b") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            Inhalt += '\n<video controls><source src="data:video/' + file.extension + ";base64," + base64 + '" type="video/' + file.extension + '"></video>\n';
          }
          if (file.extension == "mp3" || file.extension == "ogg" || file.extension == "wav" || file.extension == "flac") {
            let data = yield this.app.vault.readBinary(file);
            let base64 = import_buffer.Buffer.from(data).toString("base64");
            Inhalt += '\n<audio controls><source src="data:audio/' + file.extension + ";base64," + base64 + '" type="audio/' + file.extension + '"></audio>\n';
          }
          if (file.extension == "md") {
            let links2 = [];
            let data = yield this.app.vault.cachedRead(file);
            text = import_buffer.Buffer.from(data).toString("utf8");
            if (text.startsWith("---")) {
              let start = text.indexOf("---");
              let end = text.indexOf("---", start + 3);
              text = text.substring(end + 3);
            }
            let ankers = LinkFile.reference.link.split("#");
            console.log(ankers);
            let anker = ankers[ankers.length - 1];
            let heading = "### " + LinkFile.reference.displayText + "\n";
            if (ankers.length > 1) {
              if (anker.contains("^")) {
                console.log(anker);
                let ankercaret = text.indexOf(anker);
                text = text.substring(0, ankercaret);
                text = text.substring(text.lastIndexOf("\n"));
                heading = "";
              } else {
                let pos = text.indexOf(anker);
                if (pos == -1) {
                  text = text.substring(pos);
                } else {
                  text = text.substring(pos + anker.length);
                }
                let pos2 = text.indexOf("\n#", 30);
                if (pos2 == -1) {
                } else {
                  text = text.substring(0, pos2);
                }
              }
            }
            text = heading + text;
            let AllLinks2 = this.app.fileManager.getAllLinkResolutions();
            for (let i2 = 0; i2 < AllLinks2.length; i2++) {
              if (AllLinks2[i2].sourceFile.path == file.path) {
                links2.push(AllLinks2[i2]);
              }
            }
            let lines2 = text.split("\n");
            let nextmd = yield this.Mergedown(lines2, Inhalt, imagelist, imagename, links2);
            Inhalt = nextmd.Inhalt;
          } else {
          }
        } else {
          if (text.contains("![") && text.contains(")") && text.contains("http://") || text.contains("![") && text.contains(")") && text.contains("https://")) {
            console.log("EXTERN");
            Inhalt += text + "\n";
          } else {
            Inhalt += text + "\n";
          }
        }
      }
      return {
        Inhalt,
        imagelist,
        imagename
      };
    });
  }
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsICJidWZmZXIvaW5kZXguanMiLCAibWFpbi50cyIsICJzZXR0aW5ncy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCAiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsICIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiIsICJpbXBvcnQge1xyXG5cdEJ1ZmZlclxyXG59IGZyb20gXCIuL2J1ZmZlclwiO1xyXG5pbXBvcnQge1xyXG5cdE5vdGljZSxcclxuXHRQbHVnaW4sXHJcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCB7XHJcblx0S2luZGxlU2V0dGluZ1RhYlxyXG59IGZyb20gXCIuL3NldHRpbmdzXCI7XHJcblxyXG5cclxuXHJcbmludGVyZmFjZSBLaW5kbGVQbHVnaW5TZXR0aW5ncyB7XHJcblx0YXV0aG9yOiBzdHJpbmc7XHJcblx0c2VuZG1haWw6IHN0cmluZztcclxuXHRraW5kbGVtYWlsOiBzdHJpbmc7XHJcblx0cG9ydDogc3RyaW5nO1xyXG5cdGhvc3Q6IHN0cmluZztcclxuXHRwYXNzOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBhcnRpYWwgPCBLaW5kbGVQbHVnaW5TZXR0aW5ncyA+ID0ge1xyXG5cclxuXHRhdXRob3I6IFwiXCIsXHJcblx0c2VuZG1haWw6IFwiXCIsXHJcblx0a2luZGxlbWFpbDogXCJcIixcclxuXHRwb3J0OiBcIlwiLFxyXG5cdHNtdHBob3N0OiBcIlwiLFxyXG5cdHBhc3M6IFwiXCIsXHJcblx0ZXhwYXRoOiBcIlwiLFxyXG5cdGJhY2tlbmQ6IFwiaHR0cHM6Ly9zdGFuZWtzLmRlL2FwcHMvbWQybW9iaS9cIixcclxuXHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLaW5kbGUgZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdHNldHRpbmdzOiBLaW5kbGVQbHVnaW5TZXR0aW5ncztcclxuXHRhc3luYyBvbmxvYWQoKSB7XHJcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xyXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBLaW5kbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MubWVyZ2Vkb3duID09IHRydWUpIHtcdFx0XHJcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xyXG5cdFx0XHRpZDogJ01lcmdlZG93bicsXHJcblx0XHRcdG5hbWU6ICdNZXJnZWRvd24nLFxyXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdGxldCBJbmhhbHQ6IHN0cmluZyA9IFwiXCI7XHJcblx0XHRcdFx0bGV0IGltYWdlbGlzdDogc3RyaW5nW10gPSBbXTtcclxuXHRcdFx0XHRsZXQgaW1hZ2VuYW1lOiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0XHRcdGxldCBsaW5rczogQXJyYXkgPCBzdHJpbmcgPiA9IFtdO1xyXG5cdFx0XHRcdGxldCBsYW5nID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJsYW5ndWFnZVwiKTtcclxuXHRcdFx0XHRsZXQgZG9rdW1lbnQgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG5cdFx0XHRcdGlmIChkb2t1bWVudCA9PSBudWxsIHx8IGRva3VtZW50LmV4dGVuc2lvbiAhPSBcIm1kXCIpIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJcdTI3NEMgTm8gYWN0aXZlIC5tZCBmaWxlLiBQbGVhc2Ugb3BlbiBhIC5tZCBmaWxlIGZpcnN0IVwiKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGV0IEFsbExpbmtzID0gdGhpcy5hcHAuZmlsZU1hbmFnZXIuZ2V0QWxsTGlua1Jlc29sdXRpb25zKCk7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBBbGxMaW5rcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKEFsbExpbmtzW2ldLnNvdXJjZUZpbGUucGF0aCA9PSBkb2t1bWVudC5wYXRoKSB7XHJcblx0XHRcdFx0XHRcdGxpbmtzLnB1c2goQWxsTGlua3NbaV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNhY2hlZFJlYWQoZG9rdW1lbnQpXHJcblx0XHRcdFx0bGV0IGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKVxyXG5cdFx0XHRcdGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLk1lcmdlZG93bihsaW5lcywgSW5oYWx0LCBpbWFnZWxpc3QsIGltYWdlbmFtZSwgbGlua3MpO1xyXG5cdFx0XHRcdEluaGFsdCA9IHJlc3VsdC5JbmhhbHQ7XHJcblx0XHRcdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoLyUlW1xcc1xcU10qPyUlL2csIFwiXCIpO1xyXG5cdFx0XHRcdGxldCB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0XHRcdFx0bGV0IGV4cGF0aCA9IHRoaXMuc2V0dGluZ3MuZXhwYXRoO1xyXG5cdFx0XHRcdHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihleHBhdGgpO1xyXG5cdFx0XHRcdHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShleHBhdGggKycvJysgZG9rdW1lbnQuYmFzZW5hbWUgKyAnX21lcmdlZG93bl8nK3RpbWUrJy5tZCcsIEluaGFsdCk7XHJcblx0XHRcdFx0aWYgKGxhbmcgPT0gXCJkZVwiKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShcIlx1MjcxNFx1RkUwRiBNZXJnZWRvd24gZXJmb2xncmVpY2ghXCIpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShcIlx1MjcxNFx1RkUwRiBNZXJnZWRvd24gc3VjY2Vzc2Z1bCFcIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblxyXG5cclxuXHRcdFx0fX0pO1xyXG5cdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6ICdFeHBvcnQnLFxyXG5cdFx0XHRuYW1lOiAnRXhwb3J0JyxcclxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRsZXQgSW5oYWx0OiBzdHJpbmcgPSBcIlwiO1xyXG5cdFx0XHRcdGxldCBpbWFnZWxpc3Q6IHN0cmluZ1tdID0gW107XHJcblx0XHRcdFx0bGV0IGltYWdlbmFtZTogc3RyaW5nW10gPSBbXTtcclxuXHRcdFx0XHRsZXQgbGlua3M6IEFycmF5IDwgc3RyaW5nID4gPSBbXTtcclxuXHRcdFx0XHRsZXQgbGFuZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibGFuZ3VhZ2VcIik7XHJcblx0XHRcdFx0bGV0IGRva3VtZW50ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuXHRcdFx0XHRpZiAoZG9rdW1lbnQgPT0gbnVsbCB8fCBkb2t1bWVudC5leHRlbnNpb24gIT0gXCJtZFwiKSB7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiXHUyNzRDIE5vIGFjdGl2ZSAubWQgZmlsZS4gUGxlYXNlIG9wZW4gYSAubWQgZmlsZSBmaXJzdCFcIik7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxldCBBbGxMaW5rcyA9IHRoaXMuYXBwLmZpbGVNYW5hZ2VyLmdldEFsbExpbmtSZXNvbHV0aW9ucygpO1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgQWxsTGlua3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChBbGxMaW5rc1tpXS5zb3VyY2VGaWxlLnBhdGggPT0gZG9rdW1lbnQucGF0aCkge1xyXG5cdFx0XHRcdFx0XHRsaW5rcy5wdXNoKEFsbExpbmtzW2ldKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGRva3VtZW50KVxyXG5cdFx0XHRcdGlmIChkYXRhLnN0YXJ0c1dpdGgoJy0tLScpKSB7XHJcblx0XHRcdFx0XHRsZXQgc3RhcnQgPSBkYXRhLmluZGV4T2YoJy0tLScpO1xyXG5cdFx0XHRcdFx0bGV0IGVuZCA9IGRhdGEuaW5kZXhPZignLS0tJywgc3RhcnQgKyAzKTtcclxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhLnN1YnN0cmluZyhlbmQgKyAzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGV0IGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKVxyXG5cdFx0XHRcdGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLkdldEVib29rKGxpbmVzLCBJbmhhbHQsIGltYWdlbGlzdCwgaW1hZ2VuYW1lLCBsaW5rcyk7XHJcblx0XHRcdFx0SW5oYWx0ID0gcmVzdWx0LkluaGFsdDtcclxuXHRcdFx0XHRpbWFnZWxpc3QgPSByZXN1bHQuaW1hZ2VsaXN0O1xyXG5cdFx0XHRcdGltYWdlbmFtZSA9IHJlc3VsdC5pbWFnZW5hbWU7XHJcblx0XHRcdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoLyUlW1xcc1xcU10qPyUlL2csIFwiXCIpO1xyXG5cdFx0XHRcdEluaGFsdCA9IEluaGFsdC5yZXBsYWNlKC9gYGBkYXRhdmlld2pzW1xcc1xcU10qP2BgYC9nLCBcIlwiKTtcclxuXHRcdFx0XHRJbmhhbHQgPSBJbmhhbHQucmVwbGFjZSgvPT1bXFxzXFxTXSo/PT0vZywgXCI8dT4kJjwvdT5cIik7XHJcblx0XHRcdFx0SW5oYWx0ID0gSW5oYWx0LnJlcGxhY2UoLz09L2csIFwiXCIpO1xyXG5cdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnBhZ2VicmVhayA9PSB0cnVlKSB7XHJcblx0XHRcdFx0XHRJbmhhbHQgPSBJbmhhbHQucmVwbGFjZSgvLS0tL2csICctLS1cXG48cD48ZGl2IHN0eWxlPVwicGFnZS1icmVhay1hZnRlcjogYWx3YXlzO1wiPjwvZGl2PjwvcD5cXG4nKTt9XHJcblx0XHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0fSBcclxuXHRcdFx0XHRsZXQgaG9zdCA9IHRoaXMuc2V0dGluZ3Muc210cGhvc3Q7XHJcblx0XHRcdFx0bGV0IHBvcnQgPSB0aGlzLnNldHRpbmdzLnBvcnQ7XHJcblx0XHRcdFx0bGV0IHBhc3MgPSB0aGlzLnNldHRpbmdzLnBhc3M7XHJcblx0XHRcdFx0bGV0IGtpbmRsZW1haWwgPSB0aGlzLnNldHRpbmdzLmtpbmRsZW1haWw7XHJcblx0XHRcdFx0bGV0IHNlbmRtYWlsID0gdGhpcy5zZXR0aW5ncy5zZW5kbWFpbDtcclxuXHRcdFx0XHRsZXQgYXV0aG9yID0gdGhpcy5zZXR0aW5ncy5hdXRob3I7XHJcblx0XHRcdFx0bGV0IHVzZXIgPSB0aGlzLnNldHRpbmdzLnVzZXI7XHJcblx0XHRcdFx0bGV0IHRvYyA9IHRoaXMuc2V0dGluZ3MudG9jO1xyXG5cdFx0XHRcdGxldCBiYWNrZW5kID0gdGhpcy5zZXR0aW5ncy5iYWNrZW5kO1xyXG5cdFx0XHRcdGlmIChob3N0ID09IFwiXCIgfHwgcG9ydCA9PSBcIlwiIHx8IHBhc3MgPT0gXCJcIiB8fCBraW5kbGVtYWlsID09IFwiXCIgfHwgc2VuZG1haWwgPT0gXCJcIiB8fCBhdXRob3IgPT0gXCJcIiB8fCB1c2VyID09IFwiXCIgfHwgYmFja2VuZCA9PSBcIlwiKSB7XHJcblx0XHRcdFx0XHRpZiAobGFuZyA9PSBcImRlXCIpIHtcclxuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIkJpdHRlIGVyZ1x1MDBFNG56ZSBkaWUgRWluc3RlbGx1bmdlbi5cIik7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiUGxlYXNlIGZpbGwgaW4gdGhlIHNldHRpbmdzIVwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGxhbmcgPT0gXCJkZVwiKSB7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKCdcdUQ4M0RcdURFMDMgRGVpbiBEb2t1bWVudCAnICsgZG9rdW1lbnQuYmFzZW5hbWUgKyAnIHdpcmQgbnVuIGV4cG9ydGllcnQuJyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1x1RDgzRFx1REUwMyBZb3VyIE5vdGUgJyArIGRva3VtZW50LmJhc2VuYW1lICsgJyBpcyBiZWluZyBjb252ZXJ0ZWQgdG8gYW4gZWJvb2snKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHVybCA9IHRoaXMuc2V0dGluZ3MuYmFja2VuZDtcclxuXHRcdFx0XHR2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKCdmaWxlJyArIGksIGltYWdlbGlzdFtpXSk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhpbWFnZW5hbWVbaV0pO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coaW1hZ2VsaXN0W2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gQ292ZXJiaWxkIHRvRG9cclxuXHRcdFx0XHQvLyBmb3JtRGF0YS5hcHBlbmQoJ2NvdmVyJywgYmFzZTY0Y292ZXIpO1xyXG5cdFx0XHRcdC8vIGdldCBsYW5ndWFnZVxyXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgnbGFuZycsIGxhbmcpO1xyXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgnQmlsZGVyJywgaW1hZ2VuYW1lKTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3RleHQnLCBJbmhhbHQpO1xyXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgndGl0bGUnLCBkb2t1bWVudC5iYXNlbmFtZSk7XHJcblx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKCdhdXRob3InLCBhdXRob3IpO1xyXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZCgnZW1haWwnLCBzZW5kbWFpbCk7XHJcblx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKCdraW5kbGUnLCBraW5kbGVtYWlsKTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3BvcnQnLCBwb3J0KTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ2hvc3QnLCBob3N0KTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3Bhc3MnLCBwYXNzKTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3VzZXInLCB1c2VyKTtcclxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ3RvYycsIHRvYyk7XHJcblx0XHRcdFx0YXdhaXQgZmV0Y2godXJsLCB7XHJcblx0XHRcdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxyXG5cdFx0XHRcdFx0XHRib2R5OiBmb3JtRGF0YSxcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQudGhlbihmdW5jdGlvbiAoYm9keSkge1xyXG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGJvZHkpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdC5jYXRjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1Mjc0QyBJbnRlcm5ldGNvbm5lY3Rpb24gZXJyb3Igb3IgU2VydmVyIGlzIG9mZmxpbmVcIik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcclxuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcblx0fVxyXG5cclxuXHJcblx0YXN5bmMgZ2V0RmlsZSh0ZXh0OiBzdHJpbmcsIGxpbmtzOiBBcnJheSA8IHN0cmluZyA+ICkge1xyXG5cdFx0aWYgKHRleHQuY29udGFpbnMoXCIhW1tcIikgJiYgdGV4dC5jb250YWlucyhcIl1dXCIpKSB7XHJcblx0XHRsZXQgc3RhcnQgPSB0ZXh0LmluZGV4T2YoJyFbWycpO1xyXG5cdFx0bGV0IGVuZCA9IHRleHQuaW5kZXhPZignXV0nLCBzdGFydCArIDMpO1xyXG5cdFx0bGV0IG5hbWUgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCArIDMsIGVuZCk7XHJcblx0XHRuYW1lID0gXCIhW1tcIiArIG5hbWUgKyBcIl1dXCI7XHJcblx0XHRjb25zb2xlLmxvZyhuYW1lKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKGxpbmtzW2ldLnJlZmVyZW5jZS5vcmlnaW5hbCA9PSBuYW1lKSB7XHJcblx0XHRcdFx0Y29uc29sZS5sb2cobGlua3NbaV0ucmVmZXJlbmNlLm9yaWdpbmFsKTtcclxuXHRcdFx0XHR2YXIgZmlsZSA9IGxpbmtzW2ldO1xyXG5cdFx0XHRcdHJldHVybiBmaWxlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2V7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coXCJuaWNodCBnZWZ1bmRlblwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRpZiAobGFuZyA9PSBcImRlXCIpIHtcclxuXHRcdFx0bmV3IE5vdGljZSgnXHUyNzRDIERlaW4gRG9rdW1lbnQgZW50aFx1MDBFNGx0IHVuYXVmZ2VsXHUwMEY2c3RlIERhdGVpZW4uIEJpdHRlIGtvcnJpZ2llcmUgZGFzIScpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmV3IE5vdGljZSgnXHUyNzRDIFlvdXIgZG9jdW1lbnQgY29udGFpbnMgdW5yZXNvbHZlZCBmaWxlcy4gUGxlYXNlIGZpeCBpdCEnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcbn1cclxuXHJcblx0YXN5bmMgR2V0RWJvb2sobGluZXM6IHN0cmluZ1tdLCBJbmhhbHQ6IHN0cmluZywgaW1hZ2VsaXN0OiBzdHJpbmdbXSwgaW1hZ2VuYW1lOiBzdHJpbmdbXSwgbGlua3M6IEFycmF5IDwgc3RyaW5nID4gKSB7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0ZXh0ID0gbGluZXNbaV07XHJcblx0XHRcdFxyXG5cclxuXHRcdFx0XHJcblx0XHRcdGlmICh0ZXh0LmNvbnRhaW5zKCchW1snKSAmJiB0ZXh0LmNvbnRhaW5zKCddXScpIHx8IHRleHQuY29udGFpbnMoJyFbJykgJiYgdGV4dC5jb250YWlucygnKScpICEmJiB0ZXh0LmNvbnRhaW5zKCdodHRwOi8vJykgISYmIHRleHQuY29udGFpbnMoJ2h0dHBzOi8vJykpIHtcclxuXHJcblx0XHRcdFx0bGV0IGZpbGUgPSBhd2FpdCB0aGlzLmdldEZpbGUodGV4dCwgbGlua3MpO1xyXG5cdFx0XHRcdGxldCBMaW5rRmlsZSA9IGZpbGU7XHJcblx0XHRcdFx0ZmlsZSA9IGZpbGUucmVzb2x2ZWRGaWxlO1xyXG5cclxuXHRcdFx0XHRpZiAoZmlsZS5leHRlbnNpb24gPT0gXCJwbmdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImpwZ1wiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwianBlZ1wiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwiZ2lmXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJzdmdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImJtcFwiKSB7XHJcblx0XHRcdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWRCaW5hcnkoZmlsZSk7XHJcblx0XHRcdFx0XHRsZXQgYmFzZTY0ID0gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG5cdFx0XHRcdFx0aW1hZ2VuYW1lLnB1c2goZmlsZS5uYW1lKTtcclxuXHRcdFx0XHRcdGltYWdlbGlzdC5wdXNoKGJhc2U2NCk7XHJcblx0XHRcdFx0XHRJbmhhbHQgKz0gJ1xcbjxwPjxpbWcgY2xhc3M9XCJpbnRlcm5cIiBzcmM9XCJ1cGxvYWRzLycgKyBmaWxlLm5hbWUgKyAnXCI+PC9wPicgKyAnXFxuXFxuJztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChmaWxlLmV4dGVuc2lvbiA9PSAnbWQnKSB7XHJcblx0XHRcdFx0XHRsZXQgbGlua3MyOiBBcnJheSA8IHN0cmluZyA+ID0gW107XHJcblx0XHRcdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNhY2hlZFJlYWQoZmlsZSk7XHJcblx0XHRcdFx0XHR0ZXh0ID0gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoJ3V0ZjgnKTtcclxuXHRcdFx0XHRcdGlmICh0ZXh0LnN0YXJ0c1dpdGgoJy0tLScpKSB7XHJcblx0XHRcdFx0XHRcdGxldCBzdGFydCA9IHRleHQuaW5kZXhPZignLS0tJyk7XHJcblx0XHRcdFx0XHRcdGxldCBlbmQgPSB0ZXh0LmluZGV4T2YoJy0tLScsIHN0YXJ0ICsgMyk7XHJcblx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZyhlbmQgKyAzKTtcclxuXHRcdFx0XHRcdH1cdFx0XHJcblxyXG5cclxuXHRcdFx0XHRcdGxldCBhbmtlcnMgPSBMaW5rRmlsZS5yZWZlcmVuY2UubGluay5zcGxpdCgnIycpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYW5rZXJzKTtcclxuXHRcdFx0XHRcdGxldCBhbmtlciA9IGFua2Vyc1thbmtlcnMubGVuZ3RoIC0gMV07XHJcblx0XHRcdFx0XHRsZXQgaGVhZGluZyA9ICc8aDM+PGk+JyArIExpbmtGaWxlLnJlZmVyZW5jZS5kaXNwbGF5VGV4dCArICc8L2k+PC9oMz5cXG5cXG4nO1xyXG5cclxuXHRcdFx0XHRcdGlmIChhbmtlcnMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoYW5rZXIuY29udGFpbnMoXCJeXCIpKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYW5rZXIpO1xyXG5cdFx0XHRcdFx0XHRcdGxldCBhbmtlcmNhcmV0ID0gdGV4dC5pbmRleE9mKGFua2VyKTtcclxuXHRcdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgYW5rZXJjYXJldCk7XHJcblx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKHRleHQubGFzdEluZGV4T2YoXCJcXG5cXG5cIikpO1xyXG5cdFx0XHRcdFx0XHRcdGhlYWRpbmcgPSAnJztcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRsZXQgcG9zID0gdGV4dC5pbmRleE9mKGFua2VyKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAocG9zID09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcocG9zKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKHBvcyArIGFua2VyLmxlbmd0aCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGxldCBwb3MyID0gdGV4dC5pbmRleE9mKCdcXG4jJywgMzApO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChwb3MyID09IC0xKSB7fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBwb3MyKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRleHQgPSBoZWFkaW5nICsgdGV4dDtcclxuXHJcblx0XHRcdFx0XHRsZXQgQWxsTGlua3MyID0gdGhpcy5hcHAuZmlsZU1hbmFnZXIuZ2V0QWxsTGlua1Jlc29sdXRpb25zKCk7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IEFsbExpbmtzMi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoQWxsTGlua3MyW2ldLnNvdXJjZUZpbGUucGF0aCA9PSBmaWxlLnBhdGgpIHtcclxuXHRcdFx0XHRcdFx0XHRsaW5rczIucHVzaChBbGxMaW5rczJbaV0pO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IGxpbmVzMiA9IHRleHQuc3BsaXQoXCJcXG5cIik7XHJcblxyXG5cdFx0XHRcdFx0bGV0IG5leHRtZCA9IGF3YWl0IHRoaXMuR2V0RWJvb2sobGluZXMyLCBJbmhhbHQsIGltYWdlbGlzdCwgaW1hZ2VuYW1lLCBsaW5rczIpO1xyXG5cdFx0XHRcdFx0SW5oYWx0ID0gbmV4dG1kLkluaGFsdDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmICh0ZXh0LmNvbnRhaW5zKCchWycpICYmIHRleHQuY29udGFpbnMoJyknKSAmJiB0ZXh0LmNvbnRhaW5zKCdodHRwOi8vJykgfHwgdGV4dC5jb250YWlucygnIVsnKSAmJiB0ZXh0LmNvbnRhaW5zKCcpJykgJiYgdGV4dC5jb250YWlucygnaHR0cHM6Ly8nKSkge1xyXG5cdFx0XHRcdFx0Ly8gZ2V0IHRleHQgYmV0d2VlbiAoKVxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ0VYVEVSTicpO1xyXG5cdFx0XHRcdFx0bGV0IEltYWdlTGluayA9IHRleHQuc3Vic3RyaW5nKHRleHQuaW5kZXhPZignKCcpICsgMSwgdGV4dC5pbmRleE9mKCcpJykpO1xyXG5cdFx0XHRcdFx0SW5oYWx0ICs9ICc8cD48aW1nIGNsYXNzPVwiZXh0ZXJuXCIgc3JjPVwiJyArIEltYWdlTGluayArICdcIj48L3A+IFxcblxcbic7XHJcblx0XHRcdFx0fSBcclxuXHRcdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRcdEluaGFsdCArPSB0ZXh0ICsgXCIgXFxuXFxuXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcclxuXHRcdFxyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0SW5oYWx0LFxyXG5cdFx0XHRpbWFnZWxpc3QsXHJcblx0XHRcdGltYWdlbmFtZVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0YXN5bmMgTWVyZ2Vkb3duKGxpbmVzOiBzdHJpbmdbXSwgSW5oYWx0OiBzdHJpbmcsIGltYWdlbGlzdDogc3RyaW5nW10sIGltYWdlbmFtZTogc3RyaW5nW10sIGxpbmtzOiBBcnJheSA8IHN0cmluZyA+ICkge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgdGV4dCA9IGxpbmVzW2ldO1xyXG5cdFx0XHRcclxuXHJcblx0XHRcdFxyXG5cdFx0XHRpZiAodGV4dC5jb250YWlucygnIVtbJykgJiYgdGV4dC5jb250YWlucygnXV0nKSB8fCB0ZXh0LmNvbnRhaW5zKCchWycpICYmIHRleHQuY29udGFpbnMoJyknKSAhJiYgdGV4dC5jb250YWlucygnaHR0cDovLycpICEmJiB0ZXh0LmNvbnRhaW5zKCdodHRwczovLycpKSB7XHJcblxyXG5cdFx0XHRcdGxldCBmaWxlID0gYXdhaXQgdGhpcy5nZXRGaWxlKHRleHQsIGxpbmtzKTtcclxuXHRcdFx0XHRsZXQgTGlua0ZpbGUgPSBmaWxlO1xyXG5cdFx0XHRcdGZpbGUgPSBmaWxlLnJlc29sdmVkRmlsZTtcclxuXHJcblx0XHRcdFx0aWYgKGZpbGUuZXh0ZW5zaW9uID09IFwicG5nXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJqcGdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImpwZWdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImdpZlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwic3ZnXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJibXBcIikge1xyXG5cdFx0XHRcdFx0bGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkQmluYXJ5KGZpbGUpO1xyXG5cdFx0XHRcdFx0bGV0IGJhc2U2NCA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxuXHRcdFx0XHRcdGltYWdlbmFtZS5wdXNoKGZpbGUubmFtZSk7XHJcblx0XHRcdFx0XHRpbWFnZWxpc3QucHVzaChiYXNlNjQpO1xyXG5cdFx0XHRcdFx0SW5oYWx0ICs9ICdcXG4hWycrIGZpbGUubmFtZSArJ10oZGF0YTppbWFnZS8nKyBmaWxlLmV4dGVuc2lvbisnO2Jhc2U2NCwnICsgYmFzZTY0ICsgJylcXG4nO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGZpbGUuZXh0ZW5zaW9uID09IFwibXA0XCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJ3ZWJtXCIgIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwib2d2XCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJhdmlcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIm1vdlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwid212XCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJtcGdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIm1wZWdcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIm1rdlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwiZmx2XCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJzd2ZcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcInZvYlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwibTR2XCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJtNGFcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIm00YlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwibTRyXCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCIzZ3BcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIjNnMlwiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwiZjR2XCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJmNGFcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcImY0YlwiKSB7XHJcblx0XHRcdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWRCaW5hcnkoZmlsZSk7XHJcblx0XHRcdFx0XHRsZXQgYmFzZTY0ID0gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG5cdFx0XHRcdFx0SW5oYWx0ICs9ICdcXG48dmlkZW8gY29udHJvbHM+PHNvdXJjZSBzcmM9XCJkYXRhOnZpZGVvLycrIGZpbGUuZXh0ZW5zaW9uKyc7YmFzZTY0LCcgKyBiYXNlNjQgKyAnXCIgdHlwZT1cInZpZGVvLycrIGZpbGUuZXh0ZW5zaW9uKydcIj48L3ZpZGVvPlxcbic7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZmlsZS5leHRlbnNpb24gPT0gXCJtcDNcIiB8fCBmaWxlLmV4dGVuc2lvbiA9PSBcIm9nZ1wiIHx8IGZpbGUuZXh0ZW5zaW9uID09IFwid2F2XCIgfHwgZmlsZS5leHRlbnNpb24gPT0gXCJmbGFjXCIpIHtcclxuXHRcdFx0XHRcdGxldCBkYXRhID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZEJpbmFyeShmaWxlKTtcclxuXHRcdFx0XHRcdGxldCBiYXNlNjQgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygnYmFzZTY0Jyk7XHJcblx0XHRcdFx0XHRJbmhhbHQgKz0gJ1xcbjxhdWRpbyBjb250cm9scz48c291cmNlIHNyYz1cImRhdGE6YXVkaW8vJysgZmlsZS5leHRlbnNpb24rJztiYXNlNjQsJyArIGJhc2U2NCArICdcIiB0eXBlPVwiYXVkaW8vJysgZmlsZS5leHRlbnNpb24rJ1wiPjwvYXVkaW8+XFxuJztcclxuXHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRpZiAoZmlsZS5leHRlbnNpb24gPT0gJ21kJykge1xyXG5cdFx0XHRcdFx0bGV0IGxpbmtzMjogQXJyYXkgPCBzdHJpbmcgPiA9IFtdO1xyXG5cdFx0XHRcdFx0bGV0IGRhdGEgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xyXG5cdFx0XHRcdFx0dGV4dCA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCd1dGY4Jyk7XHJcblx0XHRcdFx0XHRpZiAodGV4dC5zdGFydHNXaXRoKCctLS0nKSkge1xyXG5cdFx0XHRcdFx0XHRsZXQgc3RhcnQgPSB0ZXh0LmluZGV4T2YoJy0tLScpO1xyXG5cdFx0XHRcdFx0XHRsZXQgZW5kID0gdGV4dC5pbmRleE9mKCctLS0nLCBzdGFydCArIDMpO1xyXG5cdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoZW5kICsgMyk7XHJcblx0XHRcdFx0XHR9XHRcdFxyXG5cclxuXHJcblx0XHRcdFx0XHRsZXQgYW5rZXJzID0gTGlua0ZpbGUucmVmZXJlbmNlLmxpbmsuc3BsaXQoJyMnKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGFua2Vycyk7XHJcblx0XHRcdFx0XHRsZXQgYW5rZXIgPSBhbmtlcnNbYW5rZXJzLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdFx0bGV0IGhlYWRpbmcgPSAnIyMjICcgKyBMaW5rRmlsZS5yZWZlcmVuY2UuZGlzcGxheVRleHQgKyAnXFxuJztcclxuXHJcblx0XHRcdFx0XHRpZiAoYW5rZXJzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGFua2VyLmNvbnRhaW5zKFwiXlwiKSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGFua2VyKTtcclxuXHRcdFx0XHRcdFx0XHRsZXQgYW5rZXJjYXJldCA9IHRleHQuaW5kZXhPZihhbmtlcik7XHJcblx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIGFua2VyY2FyZXQpO1xyXG5cdFx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZyh0ZXh0Lmxhc3RJbmRleE9mKFwiXFxuXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRoZWFkaW5nID0gJyc7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0bGV0IHBvcyA9IHRleHQuaW5kZXhPZihhbmtlcik7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHBvcyA9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKHBvcyk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZyhwb3MgKyBhbmtlci5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRsZXQgcG9zMiA9IHRleHQuaW5kZXhPZignXFxuIycsIDMwKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAocG9zMiA9PSAtMSkge30gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgcG9zMik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0ZXh0ID0gaGVhZGluZyArIHRleHQ7XHJcblxyXG5cdFx0XHRcdFx0bGV0IEFsbExpbmtzMiA9IHRoaXMuYXBwLmZpbGVNYW5hZ2VyLmdldEFsbExpbmtSZXNvbHV0aW9ucygpO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBBbGxMaW5rczIubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKEFsbExpbmtzMltpXS5zb3VyY2VGaWxlLnBhdGggPT0gZmlsZS5wYXRoKSB7XHJcblx0XHRcdFx0XHRcdFx0bGlua3MyLnB1c2goQWxsTGlua3MyW2ldKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBsaW5lczIgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xyXG5cclxuXHRcdFx0XHRcdGxldCBuZXh0bWQgPSBhd2FpdCB0aGlzLk1lcmdlZG93bihsaW5lczIsIEluaGFsdCwgaW1hZ2VsaXN0LCBpbWFnZW5hbWUsIGxpbmtzMik7XHJcblx0XHRcdFx0XHRJbmhhbHQgPSBuZXh0bWQuSW5oYWx0O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHRleHQuY29udGFpbnMoJyFbJykgJiYgdGV4dC5jb250YWlucygnKScpICYmIHRleHQuY29udGFpbnMoJ2h0dHA6Ly8nKSB8fCB0ZXh0LmNvbnRhaW5zKCchWycpICYmIHRleHQuY29udGFpbnMoJyknKSAmJiB0ZXh0LmNvbnRhaW5zKCdodHRwczovLycpKSB7XHJcblx0XHRcdFx0XHQvLyBnZXQgdGV4dCBiZXR3ZWVuICgpXHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnRVhURVJOJyk7XHJcblx0XHRcdFx0XHRJbmhhbHQgKz0gdGV4dCArIFwiXFxuXCI7XHJcblx0XHRcdFx0fSBcclxuXHRcdFx0XHRcclxuXHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRcdEluaGFsdCArPSB0ZXh0ICsgXCJcXG5cIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFxyXG5cdFx0XHJcblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRJbmhhbHQsXHJcblx0XHRcdGltYWdlbGlzdCxcclxuXHRcdFx0aW1hZ2VuYW1lXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbn0iLCAiaW1wb3J0IEtpbmRsZVBsdWdpbiBmcm9tIFwibWFpblwiO1xyXG5pbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBLaW5kbGVTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XHJcbiAgcGx1Z2luOiBLaW5kbGVQbHVnaW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEtpbmRsZVBsdWdpbikge1xyXG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xyXG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgfVxyXG5cclxuICBkaXNwbGF5KCk6IHZvaWQge1xyXG4gICAgbGV0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblxyXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJLaW5kbGUgc2V0dGluZ3NcIiB9KTtcclxuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IFwiU2V0IHlvdXIgZGF0YSBmb3IgeW91ciBLaW5kbGUuIFVzZSB5b3VyIGVtYWlsIHdoaWNoIGlzIGFwcHJvdmVkIGJ5IEFtYXpvbi5cIiB9KTtcclxuXHJcblxyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiQXV0aG9yXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiRGVmYXVsdCBhdXRob3IgZm9yIG5ldyBkb2N1bWVudHNcIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiT2JzaWRpYW5cIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRob3IpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dGhvciA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkVtYWlsXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiQXBwcm92ZWQgRW1haWwgZm9yIHlvdXIgS2luZGxlXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcInlvdUBvYnNpZGlhbi5tZFwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbmRtYWlsKVx0XHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbmRtYWlsID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiS2luZGxlbWFpbFwiKVxyXG4gICAgICAuc2V0RGVzYyhcIllvdXIgS2luZGxlIGVtYWlsXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcInlvdUBraW5kbGUuY29tXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mua2luZGxlbWFpbClcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mua2luZGxlbWFpbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlNNVFAgSG9zdFwiKVxyXG4gICAgICAuc2V0RGVzYyhcIllvdXIgU01UUCBob3N0IChlLmcuIHNtdHAuZ21haWwuY29tKVwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJzbXRwLm9ic2lkaWFuLm1kXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc210cGhvc3QpXHJcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNtdHBob3N0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiU01UUCBQb3J0XCIpXHJcbiAgICAgIC5zZXREZXNjKFwiWW91ciBTTVRQIHBvcnQgKGUuZy4gNTg3KVwiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCI0NjVcIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wb3J0KVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wb3J0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJTTVRQIFVzZXJcIilcclxuICAgICAgLnNldERlc2MoXCJVc2VybmFtZSBmb3IgeW91ciBTTVRQIHNlcnZlciBlLmcuIHlvdXIgTWFpbGFkcmVzc1wiKVxyXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cclxuICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJ5b3VAb2JzaWRpYW4ubWRcIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VyKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy51c2VyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuXHJcblxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJTTVRQIFBhc3N3b3JkXCIpXHJcbiAgICAgIC5zZXREZXNjKFwiWW91ciBTTVRQIHBhc3N3b3JkXCIpXHJcbiAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxyXG4gICAgICAgIHRleHRcclxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIioqKioqKioqXCIpXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucGFzcylcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGFzcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIkJhY2tlbmRcIilcclxuICAgICAgLnNldERlc2MoXCJZb3VyIGJhY2tlbmRhZHJlc3MgKGUuZy4gaHR0cHM6Ly9zdGFuZWtzLmRlL2FwcHMvbWQybW9iaS8pIGNhbiBiZSB1c2VkIGZvciBmcmVlIG9yIGhvc3QgeW91ciBvd24gQmFja2VuZC5cIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiaHR0cHM6Ly9vYjJraS5jb21cIilcclxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5iYWNrZW5kKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5iYWNrZW5kID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImhyXCIpO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJcdTJCNTAgU3VnZ2VzdGVkIGZlYXR1cmVzXCIgfSk7XHJcbiAgICAgXHJcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAuc2V0TmFtZShcIlBhZ2VicmVhayBieSAnLS0tJ1wiKVxyXG4gICAgICAuc2V0RGVzYyhcIlN1Z2dlc3RlZCBmZWF0dXJlOiBBY3RpdmF0ZSBwYWdlYnJlYWsgYnkgJy0tLSdcIilcclxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxyXG4gICAgICAgIHRvZ2dsZVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBhZ2VicmVhaylcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGFnZWJyZWFrID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiTWFya2Rvd24gbWVyZ2VcIilcclxuICAgICAgLnNldERlc2MoXCJTdWdnZXN0ZWQgZmVhdHVyZTogTWVyZ2UgLm1kIGZpbGVzIGludG8gb25lIGZpbGUgKGFkZHMgS2luZGxlOiBNZXJnZWRvd24gY29tbWFuZCkgUGx1Z2luIHJlbG9hZHMgYWZ0ZXIgc2F2aW5nLlwiKVxyXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XHJcbiAgICAgICAgdG9nZ2xlXHJcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWVyZ2Vkb3duKVxyXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tZXJnZWRvd24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAucGx1Z2lucy51bmxvYWRQbHVnaW4oJ29ic2lkaWFuLWtpbmRsZS1leHBvcnQnKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAucGx1Z2lucy5sb2FkUGx1Z2luKCdvYnNpZGlhbi1raW5kbGUtZXhwb3J0Jyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgIC5zZXROYW1lKFwiRXhwb3J0cGF0aFwiKVxyXG4gICAgICAuc2V0RGVzYyhcIlNldCB0aGUgcGF0aCB3aGVyZSB5b3Ugd2FudCB0byBleHBvcnQgeW91ciBmaWxlcyB0by4gKGUuZy4gL2ZvbGRlcilcIilcclxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XHJcbiAgICAgICAgdGV4dFxyXG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKFwiL2ZvbGRlclwiKVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmV4cGF0aClcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhwYXRoID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoclwiKTtcclxuICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogXCJIb3N0IHlvdXIgb3duIE9ic2lkaWFuMktpbmRsZS1Db252ZXJ0ZXIuXCJ9KTtcclxuICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJhXCIsIHsgdGV4dDogXCJGb3JrIGZyb20gR2l0aHViIFx1RDgzRFx1REQxN1wiLCBocmVmOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9TaW1lb25MdWthcy9PYnNpZGlhbjJLaW5kbGVcIn0pO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImhyXCIpO1xyXG4gICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJcdTIzRjNCZXRhIFNldHRpbmdzXCIgfSk7XHJcbiAgICAgIFxyXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuICAgICAgLnNldE5hbWUoXCJHZW5lcmF0ZSBUT0NcIilcclxuICAgICAgLnNldERlc2MoXCJHZW5lcmF0ZSBUYWJsZSBvZiBDb250ZW50cy4gVGhpcyBpcyBhIGJldGEgZmVhdHVyZSBhbmQgbWF5IG5vdCB3b3JrIGNvcnJlY3RseS5cIilcclxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxyXG4gICAgICAgIHRvZ2dsZVxyXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnRvYylcclxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudG9jID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoclwiKTtcclxuICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJhXCIsIHsgdGV4dDogXCJCdXkgbWUgYSBcdTI2MTVcIiwgaHJlZjogXCJodHRwczovL3d3dy5idXltZWFjb2ZmZWUuY29tL3NpbWVvbmx1a2FzXCJ9KTtcclxuXHJcblxyXG5cclxuICAgICAgICAgIFxyXG4gICAgfVxyXG4gICAgfVxyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUVBLFlBQVEsYUFBYTtBQUNyQixZQUFRLGNBQWM7QUFDdEIsWUFBUSxnQkFBZ0I7QUFFeEIsUUFBSSxTQUFTO0FBQ2IsUUFBSSxZQUFZO0FBQ2hCLFFBQUksTUFBTSxPQUFPLGVBQWUsY0FBYyxhQUFhO0FBRTNELFFBQUksT0FBTztBQUNYLFNBQVMsSUFBSSxHQUFHLE1BQU0sS0FBSyxRQUFRLElBQUksS0FBSyxFQUFFLEdBQUc7QUFDL0MsYUFBTyxLQUFLLEtBQUs7QUFDakIsZ0JBQVUsS0FBSyxXQUFXLE1BQU07QUFBQTtBQUZ6QjtBQUFPO0FBT2hCLGNBQVUsSUFBSSxXQUFXLE1BQU07QUFDL0IsY0FBVSxJQUFJLFdBQVcsTUFBTTtBQUUvQixxQkFBa0IsS0FBSztBQUNyQixVQUFJLE9BQU0sSUFBSTtBQUVkLFVBQUksT0FBTSxJQUFJLEdBQUc7QUFDZixjQUFNLElBQUksTUFBTTtBQUFBO0FBS2xCLFVBQUksV0FBVyxJQUFJLFFBQVE7QUFDM0IsVUFBSSxhQUFhO0FBQUksbUJBQVc7QUFFaEMsVUFBSSxrQkFBa0IsYUFBYSxPQUMvQixJQUNBLElBQUssV0FBVztB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
